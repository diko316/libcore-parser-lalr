{"version":3,"file":"libcore-parser-lalr.js","sources":["../src/state/map.js","../src/state/builder/rule.js","../src/state/define/list.js","../src/state/define/state.js","../src/state/define.js","../src/state/builder/registry.js","../src/state/builder.js","../src/lexeme.js","../src/iterator/base.js","../src/iterator.js","../src/parser.js","../src/all.js"],"sourcesContent":["'use strict';\n\n\nimport {\n            string,\n            object,\n            array,\n            contains\n            \n        } from \"libcore\";\n\nfunction StateMap() {\n    var start = \"$start\",\n        end = \"$end\",\n        tokenEnd = \"$\",\n        states = {};\n\n    this.stateGen =\n        this.symbolGen =\n        this.reduceGen = 0;\n\n    states[start] = {};\n    this.root = end;\n    this.lookup = {};\n    this.symbol = {};\n    this.start = start;\n    this.states = states;\n    this.ends = {};\n    this.exclude = {};\n    this.finalized = false;\n    this.rawStates = [];\n\n    this.reduceLookup = {};\n    this.reducers = {};\n\n    this.augmentedRoot = this.generateSymbol(end);\n    this.endSymbol = this.generateSymbol(tokenEnd);\n    this.endToken = tokenEnd;\n\n}\n\n\nStateMap.prototype = {\n    stateGen: 0,\n    rawStates: null,\n    \n    constructor: StateMap,\n\n    createState: function (id) {\n        var states = this.states;\n\n        if (id in states) {\n            return states[id];\n        }\n        return (states[id] = {});\n    },\n    \n    createPointer: function (id, token, target) {\n        var state = this.createState(id);\n\n        state[token] = target;\n\n        return state;\n\n    },\n\n    generateSymbol: function (name) {\n\n        var lookup = this.lookup,\n            symbols = this.symbol,\n            access = ':' + name;\n        var id;\n        \n        if (access in lookup) {\n            return lookup[access];\n        }\n    \n        // create symbol\n        id = 's' + (++this.symbolGen).toString(16);\n        //id = name;\n    \n        lookup[access] = id;\n        symbols[id] = name;\n    \n        return id;\n    \n    },\n\n    generateReduceId: function (name, params, ruleIndex) {\n        var lookup = this.reduceLookup,\n            all = this.reducers,\n            access = name + ':' + params + ':' + ruleIndex;\n        var id;\n\n        if (access in lookup) {\n            return lookup[access];\n        }\n\n        id = 'r' + (++this.reduceGen).toString(16);\n\n        lookup[access] = id;\n        all[id] = [name, params, ruleIndex];\n\n        return id;\n    },\n\n    lookupReducer: function (id) {\n        var all = this.reducers;\n        \n        if (id in all) {\n            return all[id];\n        }\n\n        return false;\n    },\n\n    lookupSymbol(name) {\n        var symbols = this.symbol;\n\n        if (name in symbols) {\n            return symbols[name];\n        }\n\n        return false;\n\n    },\n    \n    setReduceState: function (state, name, params, ruleIndex) {\n        var ends = this.ends,\n            id = this.generateReduceId(name, params, ruleIndex),\n            all = this.reducers;\n        var current;\n        \n        if (state in ends) {\n            current = all[ends[state]];\n            if (current[0] !== name || current[1] !== params) {\n                throw new Error(\"Reduce conflict found \" +\n                                current[0] + ' ! <- ' + name);\n            }\n        }\n        else {\n            ends[state] = id;\n        }\n        \n    },\n    \n    reset: function () {\n        this.constructor();\n    },\n\n    finalize: function() {\n        var list = this.rawStates;\n        var c, l;\n\n        if (!this.finalized && list) {\n            this.finalized = true;\n\n            for (c = -1, l = list.length; l--;) {\n                list[++c].finalize();\n            }\n\n            // remove raw states\n            list.length = 0;\n\n            // remove lookup\n            delete this.lookup;\n        }\n        \n        return this.finalized;\n    },\n    \n    setExcludes: function (exclude) {\n        var current = this.exclude;\n        var c, l;\n        \n        if (array(exclude)) {\n            for (c = -1, l = exclude.length; l--;) {\n                current[exclude[++c]] = true;\n            }\n        }\n    },\n    \n    importStates: function (definition) {\n        var isObject = object,\n            isString = string;\n        var start, states, ends, root, exclude, symbol, reducers,\n            list, c, l;\n        \n        if (!isObject(definition)) {\n            throw new Error(\"Invalid Object definition parameter.\");\n        }\n        \n        states = definition.states;\n        if (!isObject(states)) {\n            throw new Error(\n                        'Invalid \"states\" Object in definition parameter.');\n        }\n        \n        root = definition.root;\n        if (!isString(root)) {\n            throw new Error(\n                        'Invalid \"root\" grammar rule in definition parameter.');\n        }\n        \n        start = definition.start;\n        if (!isString(start) || !(start in states)) {\n            throw new Error(\n                        'Invalid \"start\" state in definition parameter.');\n        }\n        \n        ends = definition.ends;\n        if (!isObject(ends)) {\n            throw new Error('Invalid \"ends\" states in definition parameter.');\n        }\n\n        reducers = definition.reducers;\n        if (!isObject(reducers)) {\n            throw new Error('Invalid production \"reducers\" in definition.');\n        }\n\n        symbol = definition.symbol;\n        if (!isObject(symbol)) {\n            throw new Error('Invalid \"symbol\" map in definition parameter.');\n        }\n\n        list = definition.exclude;\n        if (!array(list)) {\n            throw new Error('Invalid \"exclude\" token in definition parameter.');\n        }\n\n        exclude = {};\n        for (c = -1, l = list.length; l--;) {\n            exclude[list[++c]] = true;\n        }\n        \n        this.root = root;\n        this.start = start;\n        this.states = states;\n        this.ends = ends;\n        this.reducers = reducers;\n        this.exclude = exclude;\n        this.symbol = symbol;\n        \n        return true;\n    },\n    \n    toObject: function () {\n        var has = contains,\n            exclude = this.exclude,\n            list = [],\n            len = 0;\n        var name;\n\n        // export exclude\n        for (name in exclude) {\n            if (has(exclude, name)) {\n                list[len++] = name;\n            }\n        }\n\n\n        return {\n                root: this.root,\n                start: this.start,\n                states: this.states,\n                reducers: this.reducers,\n                ends: this.ends,\n                exclude: list,\n                symbol: this.symbol\n            };\n    },\n    \n    exportStates: function (json) {\n        var current = this.toObject();\n            \n        if (json === true) {\n            try {\n                return JSON.stringify(current);\n            }\n            catch (e) {\n                return null;\n            }\n        }\n        \n        return current;\n    }\n    \n    \n};\n\n\nexport default StateMap;","'use strict';\n\nimport {\n            regex,\n            string,\n            array\n        } from \"libcore\";\n\nvar LEXEME_RE = /^([A-Z][a-zA-Z]+(\\_?[a-zA-Z0-9])*|\\$end|\\$)$/;\n\nexport\n    function isTerminal(name) {\n        return name === \"$\" || !LEXEME_RE.test(name);\n    }\n\nexport \n    function defineTerminals(registry, name, definitions) {\n        var isRegex = regex;\n        var c, l, terminal;\n\n        for (c = -1, l = definitions.length; l--;) {\n            terminal = definitions[++c];\n\n            if (!isRegex(terminal)) {\n                throw new Error(\"Invalid Terminal pattern: \" + terminal);\n            }\n\n            if (!registry.registerTerminal(terminal, name)) {\n                throw new Error(\"Invalid Terminal pattern: \" + terminal);\n            }\n\n        }\n\n    }\n\n\n\nexport \n    function defineRules(registry, name, definitions) {\n        var isString = string,\n            isRegex = regex,\n            isArray = array,\n            isTerm = isTerminal;\n\n        var c, l, rl, rule, lexeme, ruleMask, terminals, isTerminalToken;\n\n        for (c = -1, l = definitions.length; l--;) {\n            rule = definitions[++c];\n            if (isString(rule) || isRegex(rule)) {\n                rule = [rule];\n            }\n            else if (!isArray(rule)) {\n                throw new Error(\"Invalid Grammar rule declared in \" + name);\n            }\n\n            //console.log(\"define rules: \", name, \" definitions \", rule);\n\n            // create rule mask\n            rl = rule.length;\n            ruleMask = [];\n            terminals = {};\n\n            for (; rl--;) {\n                lexeme = rule[rl];\n\n                if (isRegex(lexeme)) {\n\n                    if (!registry.terminalExist(lexeme)) {\n                        registry.registerTerminal(lexeme);\n                    }\n\n                    lexeme = '/' + lexeme.source + '/';\n                    isTerminalToken = true;\n                }\n                else if (!isString(lexeme)) {\n                    throw new Error(\"Invalid Grammar rule declared in \" + name);\n                }\n                else {\n                    isTerminalToken = isTerm(lexeme);\n                }\n\n                \n                //console.log(\"hashed! \", ruleMask[rl]);\n                ruleMask[rl] = registry.map.generateSymbol(lexeme);//registry.hashLexeme(lexeme);\n\n                if (isTerminalToken) {\n                    terminals[rl] = true;\n                }\n                \n            }\n\n            // define states from ruleMask\n            registry.registerRule(name, ruleMask, terminals);\n\n        }\n\n\n\n    }","'use strict';\n\n\nfunction List(name) {\n    this.name = name;\n}\n\nList.prototype = {\n    constructor: List,\n    first: null,\n    last: null,\n\n    shift: function () {\n        var item = this.first;\n        var first;\n\n        if (item) {\n            this.first = first = item[0];\n            if (!first) {\n                this.last = first;\n            }\n            return item[1];\n        }\n        \n\n        return null;\n    },\n\n    push: function (item) {\n        item = [null, item];\n\n        if (this.last) {\n            this.last[0] = item;\n        }\n        else {\n            this.first = item;\n        }\n\n        this.last = item;\n\n        return this;\n    }\n};\n\nexport default List;","'use strict';\n\nimport List from \"./list.js\";\n\nfunction State(registry, id) {\n    var list = registry.vstates;\n\n    id = id || 's' + (++registry.vstateIdGen);\n    \n    registry.vstateLookup[id] = \n        list[list.length] = this;\n    \n    this.id = id;\n    this.registry = registry;\n    this.tags = {};\n    this.tagNames = [];\n    this.pointer = new List();\n    this.rparent = null;\n    this.recursedAs = {};\n    \n}\n\nState.prototype = {\n    pointer: null,\n    registry: null,\n    constructor: State,\n\n    tag: function (id) {\n        var list = this.tags,\n            names = this.tagNames;\n\n        if (!(id in list)) {\n            list[id] = true;\n            names[names.length] = id;\n        }\n\n        return this;\n    },\n\n    hasTag: function (id) {\n        return id in this.tags;\n    },\n\n    setRecursed: function (production) {\n        var access = ':' + production,\n            list = this.recursedAs;\n\n        if (!(access in list)) {\n            list[access] = true;\n        }\n\n        return this;\n    },\n\n    isRecursed: function (production) {\n        var access = ':' + production,\n            list = this.recursedAs;\n\n        return access in list;\n    },\n\n    findRecursion: function (id) {\n        var me = this,\n            parent = me.rparent;\n\n        for (; parent; parent = parent.rparent) {\n            if (parent.hasTag(id)) {\n                return parent;\n            }\n        }\n        return null;\n    },\n\n    pointed: function (token) {\n        var pointer = this.pointer.first;\n        var item;\n\n        for (; pointer; pointer = pointer[0]) {\n            item = pointer[1];\n            if (item[1] === token) {\n                return item[0];\n            }\n        }\n        \n        return null;\n    },\n\n    pointTo: function (token, state) {\n        this.pointer.push([state, token]);\n        return state;\n    },\n\n    point: function (token, recurseState) {\n        var pointed = this.pointed(token);\n        var newState;\n\n        // create\n        if (!pointed) {\n            newState = new State(this.registry);\n            newState.rparent = recurseState;\n\n            return this.pointTo(token, newState);\n\n        }\n\n        return pointed;\n    }\n};\n\nexport default State;","'use strict';\n\nimport State from \"./define/state.js\";\n\nimport List from \"./define/list.js\";\n\n\nfunction define(registry) {\n\n    var map = registry.map,\n        StateClass = State,\n        STATE_END = 0,\n        STATE_START = 1,\n        STATE_RUN_RULES = 2,\n        STATE_START_RULE = 3,\n        STATE_DEFINE_LEXEME = 4,\n        STATE_DEFINE_ENDER = 5,\n        STATE_END_RULES = 6,\n        Queue = List,\n        defineState = STATE_START,\n        start = new StateClass(registry, map.start),\n        queue = new Queue('queue'),\n        pending = new Queue('pending');\n\n    var item, rules, rule, rindex, rlen, lexemes, tokens,\n        id, token, lindex, llen,\n        state, production, recursion, enqueue,\n        ruleState, tagged,\n        pointed, target,\n        \n        states, pointer, c, l;\n\n    //var limit = 1000;\n\n    queue.push([start, map.augmentedRoot]);\n\n    for (; defineState;) {\n        // if (!--limit) {\n        //     break;\n        // }\n\n        switch (defineState) {\n        case STATE_START:\n            item = queue.shift();\n\n            production = item[1];\n            ruleState = item[0];\n\n            // go to next\n            if (ruleState.isRecursed(production)) {\n                defineState = STATE_END_RULES;\n                break;\n            }\n\n            ruleState.setRecursed(production);\n            rules = registry.getRules(production);\n            lexemes = rules[1];\n            rules = rules[0];\n            rindex = -1;\n            rlen = rules.length;\n            defineState = STATE_RUN_RULES;\n            \n\n        /* falls through */\n        case STATE_RUN_RULES:\n            if (!(rlen--)) {\n                defineState = STATE_END_RULES;\n                break;\n            }\n\n            rule = rules[++rindex];\n            tokens = lexemes[rindex];\n            defineState = STATE_START_RULE;\n            \n\n        /* falls through */\n        case STATE_START_RULE:\n            lindex = -1;\n            llen = tokens.length;\n\n            id = rule[0];\n            token = tokens[0];\n            state = ruleState;\n\n            if (state.hasTag(id)) {\n                defineState = STATE_RUN_RULES;\n                break;\n            }\n            \n            target = state.findRecursion(id, token);\n            if (target) {\n                pointed = target.pointed(token);\n                if (pointed && !state.pointed(token)) {\n                    state.pointTo(token, pointed);\n                }\n            }\n\n            defineState = STATE_DEFINE_LEXEME;\n\n        /* falls through */\n        case STATE_DEFINE_LEXEME:\n\n            id = rule[++lindex];\n            tagged = state.hasTag(id);\n            \n\n            // dont redefine, go to next rule\n            if (!(llen--) || tagged) {\n                defineState = tagged ?\n                                STATE_RUN_RULES : STATE_DEFINE_ENDER;\n                break;\n            }\n\n            //console.log(\"define id! \", id);\n\n            token = tokens[lindex];\n\n            // recursion\n            recursion = registry.isRecursed(id);\n            if (recursion) {\n                (state === ruleState ?\n                    queue : pending).push([state, recursion]);\n            }\n\n            state.tag(id);\n            pointed = state.pointed(token);\n            state = pointed || state.point(token, ruleState);\n\n            break;\n\n        /* falls through */\n        case STATE_DEFINE_ENDER:\n            id = rule[lindex];\n            state.tag(id);\n            registry.setEnd(state.id, production, lindex, id);\n            defineState = STATE_RUN_RULES;\n            break;\n        \n        case STATE_END_RULES:\n            enqueue = queue.last;\n\n            if (!enqueue && pending.last) {\n                queue.push(enqueue = pending.shift());\n            }\n\n            defineState = enqueue ? STATE_START : STATE_END;\n            // if (!enqueue) {\n            //     console.log(\"ended! iterations: \", 1000 - limit);\n            // }\n        }\n        \n    }\n\n    //console.log(\"iterations: \", 1000 - limit);\n\n    // generate state map\n    states = registry.vstates;\n    for (c = - 1, l = states.length; l--;) {\n        state = states[++c];\n        id = state.id;\n        pointer = state.pointer.first;\n        map.createState(id);\n\n        // apply pointer\n        for (; pointer; pointer = pointer[0]) {\n            item = pointer[1];\n            map.createPointer(id, item[1], item[0].id);\n        }\n\n        // set end\n        item = registry.isEnd(id);\n        if (item) {\n            map.setReduceState(id, item[0], item[1], item[2]);\n        }\n    }\n\n    \n\n    \n    // generate report\n    // var states = registry.vstates,\n    //     ends = registry.ends;\n    // var c, l, state, pointer, end;\n\n    // for (c = -1, l = states.length; l--;) {\n    //     state = states[++c];\n    //     pointer = state.pointer.first;\n    //     if (!pointer) {\n    //         console.log('no transitions in ', state.id);\n    //     }\n    //     for (;pointer; pointer = pointer[0]) {\n    //         item = pointer[1];\n    //         target = item[0];\n    //         end = target.id in ends ?\n    //                 ' end: ' + ends[target.id].join(',') : '';\n\n    //         console.log(state.id, ':', item[1], '->', target.id, end);\n    //     }\n    // }\n    // console.log(registry.vstates);\n    // console.log(queue, pending);\n    \n}\n\n\n\n\n\nexport default define;","'use strict';\n\nimport {\n            string,\n            contains\n        } from \"libcore\";\n\n\nfunction Registry(map, tokenizer) {\n    this.tokenizer = tokenizer;\n    this.map = map;\n\n    this.productions = {};\n    this.lexemes = {};\n\n    this.stateIndex = {};\n    this.vstateIdGen = 0;\n    this.vstateLookup = {};\n    this.vstates = [];\n    this.ends = {};\n\n\n    this.recursions = {};\n    \n    this.terminals = [];\n    this.terminalLookup = {};\n\n    this.symbolGen = 0;\n    this.symbol = {};\n    this.lookup = {};\n\n    this.stateTagIdGen = 0;\n    this.stateTagId = {};\n    this.stateTagIdLookup = {};\n\n    \n\n}\n\nRegistry.prototype = {\n    constructor: Registry,\n\n    startRule: null,\n    rules: null,\n\n    hashState: function (name) {\n        var lookup = this.stateTagIdLookup,\n            access = ':' + name;\n        var id;\n\n        if (access in lookup) {\n            return lookup[access];\n        }\n\n        id = 't' + (++this.stateTagIdGen).toString(16);\n        lookup[access] = id;\n        this.stateTagId[id] = name;\n\n        return id;\n\n    },\n\n    lookupState: function (id) {\n        var list = this.stateTagId;\n        \n        return id in list ? list[id] : null;\n    },\n\n    hashLexeme: function (name) {\n        \n        var lookup = this.lookup,\n            symbols = this.symbol,\n            access = ':' + name;\n        var id;\n        \n        if (access in lookup) {\n            return lookup[access];\n        }\n    \n        // create symbol\n        //id = 'rhash>' + (++this.symbolGen);\n        //id = name.replace(/[^a-zA-Z0-9]/, 'x');\n        id = name;\n        //id = this.map.generateSymbol(name);\n\n    \n        lookup[access] = id;\n        symbols[id] = name;\n    \n        return id;\n    \n    },\n\n    lookupLexeme: function (id) {\n        var lookup = this.lookup;\n        return id in lookup ? lookup[id] : null;\n    },\n\n    terminalExist: function (terminal) {\n        var lookup = this.terminalLookup;\n\n        return string(terminal) ?\n                    contains(lookup, terminal) :\n                    '/' + terminal.source + '/' in lookup;\n    },\n\n    registerTerminal: function (terminal, name) {\n        var lookup = this.terminalLookup,\n            names = this.terminals,\n            access = this.map.generateSymbol('/' + terminal.source + '/');\n        var list;\n\n        if (!name) {\n            name = access;\n        }\n\n        //console.log(\"registering terminal \", name);\n\n        // allow register\n        if (!(access in lookup)) {\n            \n            lookup[access] = name;\n\n            // register named\n            if (access === name) {\n                names[names.length] = name;\n\n            }\n            else if (!contains(lookup, name)) {\n                names[names.length] = name;\n                lookup[name] = [access];\n\n            }\n            else {\n                list = lookup[name];\n                list[list.length] = access;\n            }\n\n            this.tokenizer.define([name, terminal]);\n\n            return name;\n            \n        }\n\n        return false;\n\n\n    },\n\n    registerRule: function (name, mask, terminals) {\n        var states = this.stateIndex,\n            recursions = this.recursions,\n            productions = this.productions,\n            lexemes = this.lexemes,\n            rules = [],\n            rl = 0,\n            c = -1,\n            total = mask.length,\n            l = total + 1;\n        var items, id, lexeme, list, index;\n\n        if (!(name in productions)) {\n            productions[name] = [];\n            lexemes[name] = [];\n        }\n\n        list = productions[name];\n        index = list.length;\n        list[index] = rules;\n        lexemes[name][index] = mask;\n        \n        //console.log(\"------------------------------- Rules for: \" + name);\n\n        for (; l--;) {\n            lexeme = mask[++c];\n\n            items = mask.slice(0);\n            items.splice(c, 0, '.');\n            id = this.hashState(name + ' -> ' + items.join(' '));\n\n            if (id in states) {\n                throw new Error(\"Duplicate Grammar Rule found in \" + name);\n            }\n\n            rules[rl++] = id;\n\n            states[id] = id;\n\n            // non-terminal\n            if (l && !(c in terminals)) {\n                //console.log(\"recusion? \", id, \" is \", lexeme);\n                recursions[id] = lexeme;\n            }\n\n        }\n\n    },\n\n    getRules: function (production) {\n        var list = this.productions;\n\n        return production in list ?\n                    [list[production], this.lexemes[production]] : null;\n    },\n\n    isRecursed: function (id) {\n        var recursions = this.recursions;\n        return id in recursions && recursions[id];\n    },\n\n    setEnd: function (id, production, params, ruleId) {\n        var ends = this.ends,\n            state = this.vstateLookup[id];\n\n        if (!(id in ends)) {\n            ends[id] = [production, params, ruleId];\n        }\n        else if (ends[id][0] !== production) {\n            throw new Error(\"Reduce conflict! \" + state.id +\n                                \":\" + ends[id][0] + ' <- ' + production);\n        }\n        \n    },\n\n    isEnd: function (id) {\n        var ends = this.ends;\n        return id in ends && ends[id];\n    }\n};\n\n\nexport default Registry;","'use strict';\n\nimport {\n            string,\n            regex,\n            array\n            \n        } from \"libcore\";\n        \n\n\nimport  {\n            isTerminal,\n            defineTerminals,\n            defineRules\n        } from \"./builder/rule.js\";\n\nimport define from \"./define.js\";\n\nimport Registry from \"./builder/registry.js\";\n\n\n        \n\n\nfunction build(root, map, tokenizer, definitions, exclude) {\n    var isString = string,\n        isArray = array,\n        isRegex = regex,\n        \n        isTerm = isTerminal,\n        defTerminal = defineTerminals,\n        defRule = defineRules,\n        name = null,\n        original = name,\n        \n        terminalDefinition = true;\n\n    var c, l, definition, registry, excludes;\n\n\n    map.reset();\n    \n    map.root = map.generateSymbol(\"$\" + root);\n\n    registry = new Registry(map, tokenizer);\n\n    // augment root\n    definitions.splice(definitions.length,\n                       0,\n                       map.lookupSymbol(map.augmentedRoot),\n                        [[ root, map.lookupSymbol(map.endSymbol)]]);\n\n    for (c = -1, l = definitions.length; l--;) {\n        \n        definition = definitions[++c];\n        \n        if (isString(definition)) {\n\n            terminalDefinition = isTerm(definition);\n            name = map.generateSymbol(definition);\n            original = definition;\n\n        }\n        else if (name && isArray(definition)) {\n\n            (terminalDefinition ?\n                defTerminal :\n                defRule)(registry, name, definition);\n\n        }\n        else {\n            throw new Error(\"Invalid item in definitions parameter.\");\n        }\n    }\n\n    define(registry);\n\n    // register excludes\n    if (isArray(exclude)) {\n        excludes = [];\n\n        //console.log(\"excludes! \", exclude);\n        for (c = -1, l = exclude.length; l--;) {\n            definition = exclude[++c];\n            if (!isRegex(definition)) {\n                throw new Error(\"Invalid [exclude] pattern parameter.\");\n            }\n            excludes[c] = registry.registerTerminal(definition);\n\n        }\n\n        map.setExcludes(excludes);\n    }\n\n    return true;\n}\n\n\nexport default build;\n\n","'use strict';\n\nimport { contains } from \"libcore\";\n\nvar TYPE = {\n        terminal: 1,\n        nonterminal: 2,\n        compound: 3,\n        end: 4\n    };\n    \n    \n\nfunction Lexeme(type) {\n    this.terminal = false;\n    this.useType(type);\n}\n\n\nLexeme.prototype = {\n    constructor: Lexeme,\n    name: null,\n    rule: null,\n    value: null,\n    reduceCount: 0,\n    from: 0,\n    to: 0,\n    \n    parent: null,\n    first: null,\n    last: null,\n    next: null,\n    previous: null,\n    terminal: false,\n    \n    useType: function (type) {\n        var types = TYPE;\n        this.type = type = contains(types, type) ?\n                                types[type] : types.token;\n        if (type === TYPE.terminal) {\n            this.terminal = true;\n        }\n    }\n};\n\nexport {\n        TYPE as type,\n        Lexeme\n    };\n\nexport default Lexeme;","'use strict';\n\nimport {\n            string,\n            number,\n            object\n        } from \"libcore\";\n        \nimport Lexeme from \"../lexeme.js\";\n\nvar INVALID_STATE_HANDLER = \"Invalid result from state handler\";\n\nfunction BaseIterator(parser) {\n    if (!object(parser)) {\n        throw new Error(\"Invalid parser parameter.\");\n    }\n    \n    this.parser = parser;\n    this.reset();\n    \n    this.start = ':start';\n}\n\n\nBaseIterator.prototype = {\n    constructor: BaseIterator,\n    subject: '',\n    returns: false,\n    current: null,\n    ready: false,\n    completed: false,\n    error: null,\n    \n    actions: {\n        ':start': {\n            0: ':fail',\n            1: ':tokenize'\n            \n        },\n        \n        ':tokenize': {\n            0: ':fail',\n            1: ':tokenize',\n            2: ':shift',\n            3: ':reduce'\n        },\n        \n        ':shift': {\n            0: ':fail',\n            1: ':tokenize'\n        },\n        \n        ':reduce': {\n            0: ':fail',\n            1: ':shift',\n            2: ':reduce',\n            3: ':success'\n        },\n        ':fail': {},\n        ':success': {}\n    },\n    \n    ':start': function () {\n        var me = this;\n        \n        me.params = me.nextTokenIndex;\n        \n        return 1;\n    },\n    \n    ':tokenize': function (from) {\n        var me = this,\n            parser = me.parser,\n            map = parser.map,\n            ends = map.ends,\n            states = map.states,\n            state = me.pstate,\n            token = parser.tokenizer.tokenize(from,\n                                              me.subject),\n            endToken = map.endToken;\n            \n        var name, to, ref, lexeme, literal;\n\n        \n        \n        if (token) {\n            name = token[0];\n            to = token[2];\n            \n            // tokenize again\n            if (!this.isAcceptableToken(token)) {\n                me.params = to;\n                return 1;\n            }\n\n            \n            \n            lexeme = new Lexeme('terminal');\n\n            // end token is not symbolized!\n            literal = name;\n            if (name === endToken) {\n                name = map.endSymbol;\n            }\n            else {\n                literal = map.symbol[name];\n            }\n\n            \n            \n            lexeme.name = literal;\n            lexeme.symbol = name;\n            lexeme.value = token[1];\n            lexeme.from = from;\n            lexeme.to = to;\n            \n            me.nextTokenIndex = to;\n            me.params = lexeme;\n            \n            // found shift state\n            ref = states[state];\n\n            //console.log(\"token accepted! \", token, name, ' shift? ', ref);\n\n            if (name in ref) {\n                return 2;\n            }\n\n        }\n        \n        // can reduce remaining buffer\n        if (me.buffer.length && state in ends) {\n            return 3;\n        }\n        \n        // failed\n        me.params = 'Invalid token';\n        return 0;\n        \n    },\n    \n    ':shift': function (lexeme) {\n        var me = this,\n            buffer = me.buffer,\n            map = me.parser.map,\n            states = map.states,\n            state = me.pstate,\n            name = lexeme.symbol;\n        \n        buffer[buffer.length] = [state, lexeme];\n        \n        me.pstate = states[state][name];\n        me.current = lexeme;\n        me.params = null;\n        \n        // do not return \"$\" token\n        me.returns = name !== map.endSymbol;\n        me.params = me.nextTokenIndex;\n\n        //console.log(\"shift from ! \", state, lexeme.value, \" to \", me.pstate);\n        \n        return 1;\n\n    },\n    \n    ':reduce': function (lexeme) {\n        var me = this,\n            map = me.parser.map,\n            buffer = me.buffer,\n            bl = buffer.length,\n            ends = map.ends,\n            states = map.states,\n            lookup = map.symbol,\n            state = me.pstate,\n            reduce = map.lookupReducer(ends[state]),\n            name = reduce[0],\n            params = reduce[1],\n            l = params,\n            endIndex = l - 1,\n            created = new Lexeme('nonterminal'),\n            values = [];\n            \n        var litem, item, from, to, ref, last;\n        \n        created.name = lookup[name];\n        created.symbol = name;\n        created.rule = lookup[reduce[2]];\n        last = null;\n        \n        //console.log(\"reduce count? \", params, \" from \", reduce);\n        \n        for (; l--;) {\n            item = buffer[--bl];\n            state = item[0];\n            litem = item[1];\n            \n            // create range\n            from = litem.from;\n            if (l === endIndex) {\n                to = litem.to;\n            }\n            \n            // create connection\n            litem.parent = created;\n             \n            if (last) {\n                last.previous = litem;\n                litem.next = last;\n            }\n            else {\n                created.last = litem;\n            }\n            created.first = last = litem;\n            values[l] = litem.value;\n        }\n        \n        created.value = values;\n        created.from = from;\n        created.to = to;\n        \n        buffer.length = bl;\n        \n        me.current = created;\n        \n        created.reduceCount = params;\n        \n        // only if it ended\n        if (name === map.augmentedRoot) {\n            \n            // end\n            if (bl === 0) {\n                litem = created.first;\n                \n                created.useType('end');\n                created.last = litem;\n                created.value = [litem.value];\n                created.rule = lookup[map.root];\n                created.reduceCount = 1;\n                \n                me.params = created;\n                \n                return 3;\n            }\n            else {\n                me.params = 'Failed last reduce';\n                return 0;\n            }\n            \n        }\n        \n        buffer[bl++] = [state, created];\n        me.returns = true;\n        \n        // iterate\n        state = states[state][name];\n        ref = states[state];\n        \n        name = lexeme.symbol;\n        me.pstate = state;\n       \n        // shift\n        //console.log('shift? ', name, 'lexeme', lexeme, ' in ', ref);\n        if (name in ref) {\n            return 1;\n        \n        }\n        // reduce\n        else if (state in ends) {\n            return 2;\n        }\n        \n        me.params = 'failed reduce! inside :reduce';\n        return 0;\n        \n    },\n    \n    ':success': function (lexeme) {\n        var me = this;\n        \n        me.completed =\n            me.returns = true;\n\n        me.current = lexeme;\n        \n        return false;\n    },\n    \n    ':fail': function (error) {\n        var me = this;\n        \n        me.error = error;\n        me.completed = true;\n        \n        return false;\n    },\n    \n    isAcceptableToken: function (token) {\n        return !(token[0] in this.parser.map.exclude);\n    },\n    \n    update: function (value) {\n        var me = this,\n            current = me.current;\n        \n        if (!me.error && current) {\n            \n            current.value = value;\n            \n        }\n        \n        return this;\n    },\n    \n    reset: function () {\n        var parser = this.parser;\n        \n        this.nextTokenIndex = 0;\n        this.cursor = 0;\n        this.buffer = [];\n        \n        this.state = this.start;\n        this.pstate = parser.map.start;\n        this.params = null;\n        \n        if (!this.subject) {\n            delete this.ready;\n        }\n        \n        delete this.complete;\n        delete this.error;\n        \n        delete this.returns;\n        delete this.current;\n        \n    },\n    \n    set: function (subject) {\n        if (!string(subject)) {\n            throw new Error(\"Invalid String subject parameter.\");\n        }\n        \n        this.reset();\n        this.subject = subject;\n        this.ready = true;\n        \n\n    },\n    \n    next: function () {\n        var me = this,\n            actions = me.actions,\n            isNumber = number,\n            completed = me.completed,\n            returns = false;\n        var state, params, result, ref, current;\n\n        if (!me.ready) {\n            throw new Error(\"Iterator is not yet ready, nothing to Parse.\");\n        }\n\n        // reset current\n        if (!completed) {\n            delete me.current;\n        }\n        \n        for (; !completed;) {\n            \n            state = me.state;\n            params = me.params;\n            \n            // check if it action can be transitioned\n            if (!(state in me)) {\n                throw new Error(\"No handler found for state \" + state);\n            }\n            \n            // handle transition\n            result = me[state](params);\n            returns = me.returns;\n            delete me.returns;\n            current = me.current;\n            completed = me.completed;\n            \n            // break on error\n            if (me.error) {\n                break;\n            }\n            \n            // after transition, may error caught or successfully completed\n            if (!completed) {\n                \n                // accepts number result\n                if (!isNumber(result)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                    \n                // can transition to next state\n                ref = actions[state];\n                \n                if (!(result in ref)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                \n                me.state = ref[result];\n            }\n            \n            // return params\n            if (returns === true) {\n                return current;\n            }\n            \n            \n        }\n        \n        return me.error || !completed ? false : null;\n        \n    }\n};\n\nexport default BaseIterator;\n","'use strict';\n\nimport {\n            string,\n            method\n        } from \"libcore\";\n\nimport BaseIterator from \"./iterator/base.js\";\n        \nvar defaultIteratorName = \"base\",\n    ITERATORS = {};\n\nexport\n    function register(name, Class) {\n        var Base = BaseIterator;\n        \n        if (!string(name)) {\n            throw new Error(\"Invalid iterator name parameter.\");\n        }\n        \n        if (!method(Class) ||\n            (Class !== Base && !(Class.prototype instanceof Base))) {\n            throw new Error(\"Invalid iterator Class parameter.\");\n        }\n        \n        ITERATORS[':' + name] = Class;\n        \n        return true;\n    }\n\nexport\n    function get(name) {\n        var list = ITERATORS;\n        \n        if (string(name)) {\n            name = ':' + name;\n            if (name in list) {\n                return list[name];\n            }\n        }\n        \n        return null;\n    }\n\nexport {\n            defaultIteratorName as defaultIterator,\n            BaseIterator as Base\n        };\n\nregister(defaultIteratorName, BaseIterator);\n\n\n","'use strict';\n\nimport {\n            string,\n            object,\n            array\n\n        } from \"libcore\";\n\nimport Tokenizer from \"libcore-tokenizer\";\n\nimport StateMap from \"./state/map.js\";\n\nimport builder from \"./state/builder.js\";\n\nimport {\n            get as iteratorGet,\n            defaultIterator\n        } from \"./iterator.js\";\n\n\nfunction Parser(root, definition, exclude) {\n    \n    this.tokenizer = new Tokenizer();\n    this.map = new StateMap();\n    \n    if (arguments.length) {\n        this.define(root, definition, exclude);\n    }\n}\n\n\nParser.prototype = {\n    subject: '',\n    tokenizer: null,\n    map: null,\n    ready: false,\n    constructor: Parser,\n    \n    iterator: function (name) {\n        var get = iteratorGet;\n        var Iterator;\n        \n        if (arguments.length) {\n            Iterator = get(name);\n            if (!Iterator) {\n                throw new Error(\"Invalid iterator name parameter.\");\n            }\n        }\n        else {\n            Iterator = get(defaultIterator);\n        }\n        \n        return new Iterator(this);\n    },\n    \n    define: function (root, definition, exclude) {\n        var isArray = array;\n        var ready;\n        \n        if (!isArray(exclude)) {\n            exclude = [];\n        }\n        \n        if (!string(root)) {\n            throw new Error(\"Invalid root grammar rule parameter.\");\n        }\n        \n        if (!isArray(definition)) {\n            throw new Error(\"Invalid grammar rules definition parameter\");\n        }\n        \n        \n        this.ready = ready = builder(root,\n                                    this.map,\n                                    this.tokenizer,\n                                    definition,\n                                    exclude);\n        \n        return ready;\n\n    },\n    \n    fromJSON: function (json) {\n        var isObject = object;\n        var tokenMap;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\"Invalid JSON String json parameter.\");\n            }\n        }\n        \n        if (!isObject(json)) {\n            throw new Error(\"Invalid Object json parameter.\");\n        }\n        \n        tokenMap = json.tokens;\n        \n        if (!isObject(tokenMap)) {\n            throw new Error('Invalid \"tokens\" property of json parameter.');\n        }\n        \n        this.tokenizer.fromJSON(tokenMap);\n        this.map.importStates(json);\n        \n        return this;\n        \n    },\n    \n    toJSON: function () {\n        return JSON.stringify(this.toObject());\n    },\n    \n    toObject: function () {\n        var object;\n        \n        if (!this.ready) {\n            throw new Error(\"Grammar rules is not yet defined.\");\n        }\n        \n        object = this.map.toObject();\n        object.tokens = this.tokenizer.toObject();\n        \n        return object;\n    },\n    \n    parse: function (subject, reducer, iterator) {\n        var isString = string,\n            rpn = [],\n            rl = 0;\n        var lexeme, name, value;\n        \n        if (!isString(subject)) {\n            throw new Error(\"Invalid string subject parameter\");\n        }\n        \n        iterator = isString(iterator) ?\n                        this.iterator(iterator) :\n                        this.iterator();\n        \n        if (!iterator) {\n            throw new Error(\"Invalid Iterator parameter.\");\n        }\n        \n        if (!object(reducer)) {\n            reducer = {};\n        }\n        \n        iterator.set(subject);\n        \n        for (lexeme = iterator.next(); lexeme; lexeme = iterator.next()) {\n            rpn[rl++] = lexeme;\n            \n            name = lexeme.name;\n            if (name in reducer) {\n                value = reducer[name](name, lexeme.value, lexeme);\n                \n                if (typeof value !== \"undefined\") {\n                    lexeme.value = value;\n                }\n                else if (lexeme.params !== 0) {\n                    lexeme.value = null;\n                }\n                \n            }\n            \n        }\n        \n        return iterator.error ? false : rpn;\n        \n    }\n};\n\n\nexport default Parser;","'use strict';\n\nimport {\n            string,\n            object\n        } from \"libcore\";\n        \nimport Parser from \"./parser.js\";\n\nexport { Parser };\n\nexport {\n            Base as Iterator,\n            register as registerIterator\n        } from \"./iterator.js\";\n\nexport\n    function define(root, definitions, exclusions) {\n        return new Parser(root, definitions, exclusions);\n    }\n\nexport\n    function load(json) {\n        var parser;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\n                    \"Unable to load from invalid json JSON String parameter: \" +\n                    e.toString());\n            }\n        }\n        else if (!object(json)) {\n            throw new Error(\"Unable to load from invalid json Object parameter.\");\n        }\n        \n        parser = new Parser();\n        \n        try {\n            parser.fromJSON(json);\n        }\n        catch (e) {\n            throw new Error(e);\n        }\n        \n        return parser;\n    }\nexport\n    function isParser(parser) {\n        return parser instanceof Parser;\n    }\n\n\n\n\n// integrate to libcore\n//module.exports = libcore.lalr = {\n//    Parser: Parser,\n//    Iterator: iteratorManager.Base,\n//    isParser: isParser,\n//    define: define,\n//    load: load,\n//    registerIterator: iteratorManager.register\n//};"],"names":["array","object","string","contains","regex","define","this","number","method","get","iteratorGet","defaultIterator","builder"],"mappings":"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"}