{"version":3,"file":"libcore-parser-lalr.min.js","sources":["../src/state/map.js","../src/state/builder/rule.js","../src/state/define/state.js","../src/state/define/list.js","../src/state/define.js","../src/state/builder/registry.js","../src/state/builder.js","../src/lexeme.js","../src/iterator/base.js","../src/iterator.js","../src/parser.js","../src/all.js"],"sourcesContent":["'use strict';\n\n\nimport {\n            string,\n            object,\n            array,\n            contains\n            \n        } from \"libcore\";\n\nfunction StateMap(debug) {\n    var start = \"0\",\n        end = \"End\",\n        tokenEnd = \"$\",\n        states = {};\n\n    this.stateGen =\n        this.symbolGen =\n        this.reduceGen = 0;\n\n    states[start] = {};\n    this.lookup = {};\n    this.symbol = {};\n    this.start = start;\n    this.states = states;\n    this.ends = {};\n    this.exclude = {};\n    this.finalized = false;\n    this.rawStates = [];\n\n    this.reduceLookup = {};\n    this.reducers = {};\n    this.debugMode = debug === true;\n\n    this.setRoot(end);\n    this.endSymbol = this.generateSymbol(tokenEnd);\n    this.endToken = tokenEnd;\n\n}\n\n\nStateMap.prototype = {\n    stateGen: 0,\n    rawStates: null,\n    debugMode: false,\n    \n    constructor: StateMap,\n\n    setRoot: function (name) {\n        this.root = this.generateSymbol(name);\n        this.augmentedRoot = this.generateSymbol(name + \"'\");\n    },\n\n    createState: function (id) {\n        var states = this.states;\n\n        if (id in states) {\n            return states[id];\n        }\n        return (states[id] = {});\n    },\n    \n    createPointer: function (id, token, target) {\n        var state = this.createState(id);\n\n        state[token] = target;\n\n        return state;\n\n    },\n\n    generateSymbol: function (name) {\n\n        var lookup = this.lookup,\n            symbols = this.symbol,\n            access = ':' + name;\n        var id;\n        \n        if (access in lookup) {\n            return lookup[access];\n        }\n    \n        // create symbol\n        id = this.debugMode ?\n                '[' + name + ']' :\n                (++this.symbolGen).toString(36);\n\n        lookup[access] = id;\n        symbols[id] = name;\n    \n        return id;\n    \n    },\n\n    generateReduceId: function (name, params, ruleIndex) {\n        var lookup = this.reduceLookup,\n            all = this.reducers,\n            access = name + ':' + params + ':' + ruleIndex;\n        var id;\n\n        if (access in lookup) {\n            return lookup[access];\n        }\n\n        id = this.debugMode ?\n                '[' + name + ':' + params + '>' + ruleIndex + ']' :\n                (++this.reduceGen).toString(36);\n\n        lookup[access] = id;\n        all[id] = [name, params, ruleIndex];\n\n        return id;\n    },\n\n    lookupReducer: function (id) {\n        var all = this.reducers;\n        \n        if (id in all) {\n            return all[id];\n        }\n\n        return false;\n    },\n\n    lookupSymbol(name) {\n        var symbols = this.symbol;\n\n        if (name in symbols) {\n            return symbols[name];\n        }\n\n        return false;\n\n    },\n    \n    setReduceState: function (state, name, params, ruleIndex) {\n        var ends = this.ends,\n            id = this.generateReduceId(name, params, ruleIndex),\n            all = this.reducers;\n        var current;\n        \n        if (state in ends) {\n            current = all[ends[state]];\n            if (current[0] !== name || current[1] !== params) {\n                throw new Error(\"Reduce conflict found \" +\n                                this.lookupSymbol(current[0]) + ' ! <- ' +\n                                this.lookupSymbol(name));\n            }\n        }\n        else {\n            ends[state] = id;\n        }\n        \n    },\n    \n    reset: function () {\n        this.constructor(this.debugMode);\n    },\n\n    finalize: function() {\n        var list = this.rawStates;\n        var c, l;\n\n        if (!this.finalized && list) {\n            this.finalized = true;\n\n            for (c = -1, l = list.length; l--;) {\n                list[++c].finalize();\n            }\n\n            // remove raw states\n            list.length = 0;\n\n            // remove lookup\n            delete this.lookup;\n        }\n        \n        return this.finalized;\n    },\n    \n    setExcludes: function (exclude) {\n        var current = this.exclude;\n        var c, l;\n        \n        if (array(exclude)) {\n            for (c = -1, l = exclude.length; l--;) {\n                current[exclude[++c]] = true;\n            }\n        }\n    },\n    \n    importStates: function (definition) {\n        var isObject = object,\n            isString = string;\n        var start, states, ends, root, exclude, symbol, reducers, augmentedRoot,\n            list, c, l;\n        \n        if (!isObject(definition)) {\n            throw new Error(\"Invalid Object definition parameter.\");\n        }\n        \n        states = definition.states;\n        if (!isObject(states)) {\n            throw new Error(\n                        'Invalid \"states\" Object in definition parameter.');\n        }\n        \n        root = definition.root;\n        if (!isString(root)) {\n            throw new Error(\n                        'Invalid \"root\" grammar rule in definition parameter.');\n        }\n\n        augmentedRoot = definition.augmentedRoot;\n        if (!isString(augmentedRoot)) {\n            throw new Error(\n            'Invalid \"augmentedRoot\" grammar rule in definition parameter.');\n        }\n        \n        start = definition.start;\n        if (!isString(start) || !(start in states)) {\n            throw new Error(\n                        'Invalid \"start\" state in definition parameter.');\n        }\n        \n        ends = definition.ends;\n        if (!isObject(ends)) {\n            throw new Error('Invalid \"ends\" states in definition parameter.');\n        }\n\n        reducers = definition.reducers;\n        if (!isObject(reducers)) {\n            throw new Error('Invalid production \"reducers\" in definition.');\n        }\n\n        symbol = definition.symbol;\n        if (!isObject(symbol)) {\n            throw new Error('Invalid \"symbol\" map in definition parameter.');\n        }\n\n        list = definition.exclude;\n        if (!array(list)) {\n            throw new Error('Invalid \"exclude\" token in definition parameter.');\n        }\n\n        exclude = {};\n        for (c = -1, l = list.length; l--;) {\n            exclude[list[++c]] = true;\n        }\n\n\n        this.augmentedRoot = augmentedRoot;\n        this.root = root;\n        this.start = start;\n        this.states = states;\n        this.ends = ends;\n        this.reducers = reducers;\n        this.exclude = exclude;\n        this.symbol = symbol;\n        \n        return true;\n    },\n    \n    toObject: function () {\n        var has = contains,\n            exclude = this.exclude,\n            list = [],\n            len = 0;\n        var name;\n\n        // export exclude\n        for (name in exclude) {\n            if (has(exclude, name)) {\n                list[len++] = name;\n            }\n        }\n\n\n        return {\n                augmentedRoot: this.augmentedRoot,\n                root: this.root,\n                start: this.start,\n                states: this.states,\n                reducers: this.reducers,\n                ends: this.ends,\n                exclude: list,\n                symbol: this.symbol\n            };\n    },\n    \n    exportStates: function (json) {\n        var current = this.toObject();\n            \n        if (json === true) {\n            try {\n                return JSON.stringify(current);\n            }\n            catch (e) {\n                return null;\n            }\n        }\n        \n        return current;\n    }\n    \n    \n};\n\n\nexport default StateMap;","'use strict';\n\nimport {\n            regex,\n            string,\n            array\n        } from \"libcore\";\n\nvar NONTERMINAL_RE = /^([A-Z][a-zA-Z]+(\\_?[a-zA-Z0-9])*\\'?)$/;\n\nexport\n    function isTerminal(name) {\n        return name === \"$\" || !NONTERMINAL_RE.test(name);\n    }\n\nexport \n    function defineTerminals(registry, name, definitions) {\n        var isRegex = regex;\n        var c, l, terminal;\n\n        for (c = -1, l = definitions.length; l--;) {\n            terminal = definitions[++c];\n\n            if (!isRegex(terminal)) {\n                throw new Error(\"Invalid Terminal pattern: \" + terminal);\n            }\n\n            if (!registry.registerTerminal(terminal, name)) {\n                throw new Error(\"Invalid Terminal pattern: \" + terminal);\n            }\n\n        }\n\n    }\n\n\n\nexport \n    function defineRules(registry, name, definitions) {\n        var isString = string,\n            isRegex = regex,\n            isArray = array,\n            isTerm = isTerminal;\n\n        var c, l, rl, rule, lexeme, ruleMask, terminals, isTerminalToken;\n\n        for (c = -1, l = definitions.length; l--;) {\n            rule = definitions[++c];\n            if (isString(rule) || isRegex(rule)) {\n                rule = [rule];\n            }\n            else if (!isArray(rule)) {\n                throw new Error(\"Invalid Grammar rule declared in \" + name);\n            }\n\n            //console.log(\"define rules: \", name, \" definitions \", rule);\n\n            // create rule mask\n            rl = rule.length;\n            ruleMask = [];\n            terminals = {};\n\n            for (; rl--;) {\n                lexeme = rule[rl];\n\n                if (isRegex(lexeme)) {\n\n                    if (!registry.terminalExist(lexeme)) {\n                        registry.registerTerminal(lexeme);\n                    }\n\n                    lexeme = '/' + lexeme.source + '/';\n                    isTerminalToken = true;\n                }\n                else if (!isString(lexeme)) {\n                    throw new Error(\"Invalid Grammar rule declared in \" + name);\n                }\n                else {\n                    isTerminalToken = isTerm(lexeme);\n                }\n\n                \n                //console.log(\"hashed! \", ruleMask[rl]);\n                ruleMask[rl] = registry.map.generateSymbol(lexeme);//registry.hashLexeme(lexeme);\n\n                if (isTerminalToken) {\n                    terminals[rl] = true;\n                }\n                \n            }\n\n            // define states from ruleMask\n            registry.registerRule(name, ruleMask, terminals);\n\n        }\n\n\n\n    }","'use strict';\n\n//import List from \"./list.js\";\n\nfunction State(registry, id, items) {\n\n    this.id = id;\n    this.registry = registry;\n    this.items = items || [];\n    this.end = null;\n\n    this.tokens = [];\n    this.pointers = {};\n}\n\nState.prototype = {\n    constructor: State,\n    \n    containsItems: function (items) {\n        var myItems = this.items,\n            total = myItems.length;\n        var subject, mylen, len;\n\n        if (items.length === total) {\n            mylen = total;\n            mainLoop: for (; mylen--;) {\n                subject = myItems[mylen];\n                len = total;\n                for (; len--;) {\n                    if (subject === items[len]) {\n                        continue mainLoop;\n                    }\n                }\n                return false;\n            }\n            return true;\n        }\n        return false;\n    },\n\n    pointTo: function (token, targetState) {\n        var names = this.tokens,\n            pointers = this.pointers;\n\n        if (token in pointers) {\n            if (pointers[token] !== targetState) {\n                throw new Error(\"Invalid state target from \" + this.id +\n                                        \" -> \" + token + \" -> \" + targetState);\n            }\n        }\n        else {\n            pointers[token] = targetState;\n            names[names.length] = token;\n        }\n    },\n\n    setEnd: function (item) {\n        var current = this.end;\n        if (current) {\n            throw new Error(\"There is reduce-reduce conflict in: \" +\n                                item.id + \" <- \" + item.production +\n                                \" from state: \", this.id);\n        }\n        \n        this.end = [item.params, item.production, item.id];\n    }\n\n};\n\nexport default State;","'use strict';\n\n\nfunction List(name) {\n    this.name = name;\n}\n\nList.prototype = {\n    constructor: List,\n    first: null,\n    last: null,\n\n    shift: function () {\n        var item = this.first;\n        var first;\n\n        if (item) {\n            this.first = first = item[0];\n            if (!first) {\n                this.last = first;\n            }\n            return item[1];\n        }\n        \n\n        return null;\n    },\n\n    pop: function () {\n        var item = this.last;\n        var last;\n\n        if (item) {\n            this.last = last = item[0];\n            if (!last) {\n                this.first = last;\n            }\n            return item[1];\n        }\n        \n\n        return null;\n    },\n\n    push: function (item) {\n        item = [null, item];\n\n        if (this.last) {\n            this.last[0] = item;\n        }\n        else {\n            this.first = item;\n        }\n\n        this.last = item;\n\n        return this;\n    }\n};\n\nexport default List;","'use strict';\n\nimport State from \"./define/state.js\";\n\nimport List from \"./define/list.js\";\n\nfunction define(registry) {\n\n    var map = registry.map,\n        StateClass = State,\n        productionStatesIndex = registry.productions,\n        closureDefinitions = registry.closureItems,\n        stateDefineQueue = new List(),\n        STATE_END = 0,\n        STATE_CREATE_INITIAL = 1,\n        STATE_CREATE_GOTO = 2,\n        STATE_CREATE_STATE = 3,\n        defineState = STATE_CREATE_INITIAL,\n        production = map.augmentedRoot,\n        states = [],\n        sl = 0;\n\n    var list, c, l, item, items, token, total, tokens, id, lookup,\n        stateBefore, state, end;\n\n\n    //var limit = 100;\n\n    \n    for (; defineState;) {\n        switch (defineState) {\n\n        // create initial closure from production\n        //  - requires \"production\" set\n        case STATE_CREATE_INITIAL:\n            // new closures\n            item = registry.createClosure(productionStatesIndex[production]);\n            list = item[1];\n\n            // create state from closure\n            sl = states.length;\n            state = states[sl] = new StateClass(registry,\n                                                sl.toString(32),\n                                                item[0]);\n\n            // queue transitions\n            c = -1;\n            l = list.length;\n            for (; l--;) {\n                item = list[++c];\n                stateDefineQueue.push([state, item[1], item[0]]);\n            }\n\n\n            if (!stateDefineQueue.first) {\n                defineState = STATE_END;\n                break;\n            }\n\n            defineState = STATE_CREATE_GOTO;\n            break;\n            \n\n        /* falls through */\n        // requires \"list\"\n        case STATE_CREATE_GOTO:\n            item = stateDefineQueue.shift();\n            stateBefore = item[0];\n            list = item[1];\n            token = item[2];\n            item = registry.createClosure(list);\n            items = item[0];\n            tokens = item[1];\n\n            // find states having the same closure items\n            total = sl = states.length;\n            state = null;\n            for (; sl--;) {\n                item = states[sl];\n                if (item.containsItems(items)) {\n                    state = item;\n                    break;\n                }\n            }\n\n            // create state if no state found\n            if (!state) {\n                sl = total++;\n                state = states[sl] = new StateClass(registry,\n                                                    sl.toString(32),\n                                                    items);\n\n                // queue transitions\n                c = -1;\n                l = tokens.length;\n                for (; l--;) {\n                    item = tokens[++c];\n                    stateDefineQueue.push([state, item[1], item[0]]);\n                }\n\n                // apply end state for each end items\n                c = -1;\n                l = items.length;\n                for (; l--;) {\n                    item = closureDefinitions[items[++c]];\n                    if (!item.after) {\n                        state.setEnd(item);\n                    }\n                }\n\n            }\n\n            \n\n\n\n            // point state before to new state\n            stateBefore.pointTo(token, state);\n\n            // create next state\n            defineState = stateDefineQueue.first ?\n                                STATE_CREATE_GOTO : STATE_END;\n            break;\n\n            \n        /* falls through */\n        case STATE_END:\n            defineState = null;\n        }\n\n        \n\n        // if (!--limit) {\n        //     console.log(\"limit reached\");\n        //     break;\n        // }\n    }\n\n    // finalize map\n    sl = states.length;\n    for (; sl--;) {\n        item = states[sl];\n        id = item.id;\n        state = map.createState(id);\n        tokens = item.tokens;\n        lookup = item.pointers;\n        c = -1;\n        l = tokens.length;\n        for (; l--;) {\n            token = tokens[++c];\n            map.createPointer(id, token, lookup[token].id);\n        }\n        \n        item = item.end;\n        if (item) {\n            map.setReduceState(id, item[1], item[0], item[2]);\n        }\n    }\n    \n}\n\n\n\n\n\nexport default define;","'use strict';\n\nimport {\n            string,\n            contains\n        } from \"libcore\";\n\n\nfunction Registry(map, tokenizer) {\n    this.tokenizer = tokenizer;\n    this.map = map;\n\n    this.ruleLookup = {};\n    this.productions = {};\n    this.closureItems = {};\n\n    // this.productions = {};\n    // this.productionNames = [];\n    // this.lexemes = {};\n    // this.closures = {};\n\n    // this.stateIndex = {};\n    // this.vstateIdGen = 0;\n    // this.vstateLookup = {};\n    // this.vstates = [];\n    // this.ends = {};\n\n    // this.rules = {};\n    // this.recursions = {};\n    \n    this.terminals = [];\n    this.terminalLookup = {};\n\n    // this.symbolGen = 0;\n    // this.symbol = {};\n    // this.lookup = {};\n\n    this.stateTagIdGen = 0;\n    this.stateTagId = {};\n    this.stateTagIdLookup = {};\n\n    \n\n}\n\nRegistry.prototype = {\n    constructor: Registry,\n\n    startRule: null,\n    rules: null,\n\n    hashState: function (name) {\n        var lookup = this.stateTagIdLookup,\n            access = ':' + name;\n        var id;\n\n        if (access in lookup) {\n            return lookup[access];\n        }\n\n        id = this.map.debugMode ?\n                ':' + name :\n                (++this.stateTagIdGen).toString(36);\n\n        lookup[access] = id;\n        this.stateTagId[id] = name;\n\n        return id;\n\n    },\n\n    lookupState: function (id) {\n        var list = this.stateTagId;\n        \n        return id in list ? list[id] : null;\n    },\n\n    hashLexeme: function (name) {\n        \n        var lookup = this.lookup,\n            symbols = this.symbol,\n            access = ':' + name;\n        var id;\n        \n        if (access in lookup) {\n            return lookup[access];\n        }\n    \n        // create symbol\n        id = this.map.debugMode ?\n                '[' + name + ']' :\n                (++this.symbolGen).toString(36);\n    \n        lookup[access] = id;\n        symbols[id] = name;\n    \n        return id;\n    \n    },\n\n    lookupLexeme: function (id) {\n        var lookup = this.lookup;\n        return id in lookup ? lookup[id] : null;\n    },\n\n    terminalExist: function (terminal) {\n        var lookup = this.terminalLookup;\n\n        return string(terminal) ?\n                    contains(lookup, terminal) :\n                    '/' + terminal.source + '/' in lookup;\n    },\n\n    registerTerminal: function (terminal, name) {\n        var lookup = this.terminalLookup,\n            names = this.terminals,\n            access = this.map.generateSymbol('/' + terminal.source + '/');\n        var list;\n\n        if (!name) {\n            name = access;\n        }\n\n        // allow register\n        if (!(access in lookup)) {\n            \n            lookup[access] = name;\n\n            // register named\n            if (access === name) {\n                names[names.length] = name;\n\n            }\n            else if (!contains(lookup, name)) {\n                names[names.length] = name;\n                lookup[name] = [access];\n\n            }\n            else {\n                list = lookup[name];\n                list[list.length] = access;\n            }\n\n            this.tokenizer.define([name, terminal]);\n\n            return name;\n            \n        }\n\n        return false;\n\n\n    },\n\n    registerRule: function (name, mask, terminals) {\n        var closureItems = this.closureItems,\n            rules = this.productions,\n            ruleIndex = this.ruleLookup,\n            c = -1,\n            l = mask.length + 1,\n            before = null,\n            params = 0;\n        var items, state, item;\n\n        if (!(name in rules)) {\n            rules[name] = [];\n        }\n\n        rules = rules[name];\n\n        for (; l--;) {\n            items = mask.slice(0);\n            items.splice(++c, 0, '.');\n            state = this.hashState(name + '->' + items.join(' '));\n\n            // first\n            if (!c) {\n                if (state in ruleIndex) {\n                    throw new Error(\"Duplicate Grammar Rule found \" +\n                                    this.lookupState(state) +\n                                    \" in production: \" +\n                                    this.map.lookupSymbol(name));\n                }\n                ruleIndex[state] = name;\n\n                // register production state\n                rules[rules.length] = state;\n            }\n\n            closureItems[state] =\n                item = {\n                    id: state,\n                    production: name,\n                    before: null,\n                    after: null,\n                    terminal: false,\n                    token: null\n                };\n\n            if (before) {\n                item.before = before.id;\n                before.after = state;\n            }\n            \n            before = item;\n\n            // has token lookup\n            if (l) {\n                params++;\n                item.terminal = c in terminals;\n                item.token = mask[c];\n            }\n            else {\n                item.params = params;\n            }\n            \n        }\n\n    },\n\n    createClosure: function (items) {\n        var definitions = this.closureItems,\n            productionItems = this.productions,\n            created = {},\n            processed = {},\n            tokens = [],\n            tl = 0,\n            c = -1,\n            l = items.length;\n        var item, token, terminal, list, additional;\n\n        items = items.slice(0);\n\n        for (; l--;) {\n            item = items[++c];\n            if (item in created) {\n                items.splice(c--, 1);\n                continue;\n            }\n            created[item] = true;\n            item = definitions[item];\n            token = item.token;\n            terminal = item.terminal;\n\n            if (token) {\n                \n                if (token in processed) {\n                    list = tokens[processed[token]][1];\n                    list[list.length] = item.after;\n                }\n                else {\n                    processed[token] = tl;\n                    tokens[tl++] = [token, [item.after]];\n\n                    // non-terminal\n                    if (!terminal) {\n                        // recurse get additional production first states\n                        additional = productionItems[token];\n                        items.push.apply(items, additional);\n                        l += additional.length;\n\n                    }\n                }\n\n            }\n        }\n\n        return [items, tokens];\n\n    }\n};\n\n\nexport default Registry;","'use strict';\n\nimport {\n            string,\n            regex,\n            array\n            \n        } from \"libcore\";\n        \n\n\nimport  {\n            isTerminal,\n            defineTerminals,\n            defineRules\n        } from \"./builder/rule.js\";\n\nimport define from \"./define.js\";\n\nimport Registry from \"./builder/registry.js\";\n\n\n        \n\n\nfunction build(root, map, tokenizer, definitions, exclude) {\n    var isString = string,\n        isArray = array,\n        isRegex = regex,\n        \n        isTerm = isTerminal,\n        defTerminal = defineTerminals,\n        defRule = defineRules,\n        name = null,\n        original = name,\n        \n        terminalDefinition = true;\n\n    var c, l, definition, registry, excludes;\n\n\n    map.reset();\n    map.setRoot(root);\n\n    registry = new Registry(map, tokenizer);\n\n    // augment root\n    definitions.splice(definitions.length,\n                       0,\n                       map.lookupSymbol(map.augmentedRoot),\n                        [[ root, map.lookupSymbol(map.endSymbol)]]);\n\n    for (c = -1, l = definitions.length; l--;) {\n        \n        definition = definitions[++c];\n        \n        if (isString(definition)) {\n\n            terminalDefinition = isTerm(definition);\n            name = map.generateSymbol(definition);\n            original = definition;\n\n        }\n        else if (name && isArray(definition)) {\n\n            (terminalDefinition ?\n                defTerminal :\n                defRule)(registry, name, definition);\n\n        }\n        else {\n            throw new Error(\"Invalid item in definitions parameter.\");\n        }\n    }\n\n    define(registry);\n\n    // register excludes\n    if (isArray(exclude)) {\n        excludes = [];\n\n        //console.log(\"excludes! \", exclude);\n        for (c = -1, l = exclude.length; l--;) {\n            definition = exclude[++c];\n            if (isRegex(definition)) {\n                definition = registry.registerTerminal(definition);\n            }\n            else if (isString(definition)) {\n                definition = map.generateSymbol(definition);\n            }\n            else {\n                throw new Error(\"Invalid [exclude] pattern parameter.\");\n            }\n            \n            excludes[c] = definition;\n\n        }\n\n        map.setExcludes(excludes);\n    }\n\n    return true;\n}\n\n\nexport default build;\n\n","'use strict';\n\nimport { contains } from \"libcore\";\n\nvar TYPE = {\n        terminal: 1,\n        nonterminal: 2,\n        compound: 3,\n        end: 4\n    };\n    \n    \n\nfunction Lexeme(type) {\n    this.terminal = false;\n    this.useType(type);\n}\n\n\nLexeme.prototype = {\n    constructor: Lexeme,\n    name: null,\n    rule: null,\n    value: null,\n    reduceCount: 0,\n    from: 0,\n    to: 0,\n    \n    parent: null,\n    first: null,\n    last: null,\n    next: null,\n    previous: null,\n    terminal: false,\n    \n    useType: function (type) {\n        var types = TYPE;\n        this.type = type = contains(types, type) ?\n                                types[type] : types.token;\n        if (type === TYPE.terminal) {\n            this.terminal = true;\n        }\n    }\n};\n\nexport {\n        TYPE as type,\n        Lexeme\n    };\n\nexport default Lexeme;","'use strict';\n\nimport {\n            string,\n            number,\n            object\n        } from \"libcore\";\n        \nimport Lexeme from \"../lexeme.js\";\n\nvar INVALID_STATE_HANDLER = \"Invalid result from state handler\";\n\nfunction BaseIterator(parser) {\n    if (!object(parser)) {\n        throw new Error(\"Invalid parser parameter.\");\n    }\n    \n    this.parser = parser;\n    this.reset();\n    \n    this.start = ':start';\n}\n\n\nBaseIterator.prototype = {\n    constructor: BaseIterator,\n    subject: '',\n    returns: false,\n    current: null,\n    ready: false,\n    completed: false,\n    error: null,\n    \n    actions: {\n        ':start': {\n            0: ':fail',\n            1: ':tokenize'\n            \n        },\n        \n        ':tokenize': {\n            0: ':fail',\n            1: ':tokenize',\n            2: ':shift',\n            3: ':reduce'\n        },\n        \n        ':shift': {\n            0: ':fail',\n            1: ':tokenize'\n        },\n        \n        ':reduce': {\n            0: ':fail',\n            1: ':shift',\n            2: ':reduce',\n            3: ':success'\n        },\n        ':fail': {},\n        ':success': {}\n    },\n    \n    ':start': function () {\n        var me = this;\n        \n        me.params = me.nextTokenIndex;\n        \n        return 1;\n    },\n    \n    ':tokenize': function (from) {\n        var me = this,\n            parser = me.parser,\n            map = parser.map,\n            ends = map.ends,\n            states = map.states,\n            state = me.pstate,\n            token = parser.tokenizer.tokenize(from,\n                                              me.subject),\n            endToken = map.endToken;\n            \n        var name, to, ref, lexeme, literal;\n        \n        if (token) {\n            name = token[0];\n            to = token[2];\n            \n            // tokenize again\n            if (!this.isAcceptableToken(token)) {\n                me.params = to;\n                return 1;\n            }\n\n            \n            \n            lexeme = new Lexeme('terminal');\n\n            // end token is not symbolized!\n            literal = name;\n            if (name === endToken) {\n                name = map.endSymbol;\n            }\n            else {\n                literal = map.symbol[name];\n            }\n\n            \n            \n            lexeme.name = literal;\n            lexeme.symbol = name;\n            lexeme.value = token[1];\n            lexeme.from = from;\n            lexeme.to = to;\n            \n            me.nextTokenIndex = to;\n            me.params = lexeme;\n            \n            // found shift state\n            ref = states[state];\n\n            //console.log(\"token accepted! \", token, name, ' shift? ', ref);\n\n            if (name in ref) {\n                return 2;\n            }\n\n        }\n        \n        // can reduce remaining buffer\n        if (me.buffer.length && state in ends) {\n            return 3;\n        }\n        \n        // failed\n        me.params = 'Invalid token';\n        return 0;\n        \n    },\n    \n    ':shift': function (lexeme) {\n        var me = this,\n            buffer = me.buffer,\n            map = me.parser.map,\n            states = map.states,\n            state = me.pstate,\n            name = lexeme.symbol;\n        \n        buffer[buffer.length] = [state, lexeme];\n        \n        me.pstate = states[state][name];\n        me.current = lexeme;\n        me.params = null;\n        \n        // do not return \"$\" token\n        me.returns = name !== map.endSymbol;\n        me.params = me.nextTokenIndex;\n\n        //console.log(\"shift from ! \", state, lexeme.value, \" to \", me.pstate);\n        \n        return 1;\n\n    },\n    \n    ':reduce': function (lexeme) {\n        var me = this,\n            map = me.parser.map,\n            buffer = me.buffer,\n            bl = buffer.length,\n            ends = map.ends,\n            states = map.states,\n            lookup = map.symbol,\n            state = me.pstate,\n            reduce = map.lookupReducer(ends[state]),\n            name = reduce[0],\n            params = reduce[1],\n            l = params,\n            endIndex = l - 1,\n            created = new Lexeme('nonterminal'),\n            values = [];\n            \n        var litem, item, from, to, ref, last;\n        \n        created.name = lookup[name];\n        created.symbol = name;\n        last = null;\n        \n        //console.log(\"reduce count? \", state, \"?\", params, \" from \", reduce, \" buffer \", buffer.slice(0));\n        \n        for (; l--;) {\n            item = buffer[--bl];\n            state = item[0];\n            litem = item[1];\n            \n            // create range\n            from = litem.from;\n            if (l === endIndex) {\n                to = litem.to;\n            }\n            \n            // create connection\n            litem.parent = created;\n             \n            if (last) {\n                last.previous = litem;\n                litem.next = last;\n            }\n            else {\n                created.last = litem;\n            }\n            created.first = last = litem;\n            values[l] = litem.value;\n        }\n        \n        created.value = values;\n        created.from = from;\n        created.to = to;\n        \n        buffer.length = bl;\n        \n        me.current = created;\n        \n        created.reduceCount = params;\n        \n        // only if it ended\n        if (name === map.augmentedRoot) {\n            \n            // end\n            if (bl === 0) {\n                litem = created.first;\n                \n                created.useType('end');\n                created.last = litem;\n                created.value = [litem.value];\n                created.reduceCount = 1;\n                \n                me.params = created;\n                \n                return 3;\n            }\n            else {\n                me.params = 'Failed last reduce';\n                return 0;\n            }\n            \n        }\n        //console.log(\"reduced: \", state, ' <- ', created);\n        buffer[bl++] = [state, created];\n        me.returns = true;\n        \n        // iterate\n        state = states[state][name];\n        ref = states[state];\n        \n        name = lexeme.symbol;\n        me.pstate = state;\n       \n        // shift\n        //console.log('shift? ', name, 'lexeme', lexeme, ' in ', state, ':', ref);\n        if (name in ref) {\n            return 1;\n        \n        }\n        // reduce\n        else if (state in ends) {\n            return 2;\n        }\n        \n        me.params = 'failed reduce! inside :reduce';\n        return 0;\n        \n    },\n    \n    ':success': function (lexeme) {\n        var me = this;\n        \n        me.completed =\n            me.returns = true;\n\n        me.current = lexeme;\n        \n        return false;\n    },\n    \n    ':fail': function (error) {\n        var me = this;\n        \n        me.error = error;\n        me.completed = true;\n        \n        return false;\n    },\n    \n    isAcceptableToken: function (token) {\n        return !(token[0] in this.parser.map.exclude);\n    },\n    \n    update: function (value) {\n        var me = this,\n            current = me.current;\n        \n        if (!me.error && current) {\n            \n            current.value = value;\n            \n        }\n        \n        return this;\n    },\n    \n    reset: function () {\n        var parser = this.parser;\n        \n        this.nextTokenIndex = 0;\n        this.cursor = 0;\n        this.buffer = [];\n        \n        this.state = this.start;\n        this.pstate = parser.map.start;\n        this.params = null;\n        \n        if (!this.subject) {\n            delete this.ready;\n        }\n        \n        delete this.complete;\n        delete this.error;\n        \n        delete this.returns;\n        delete this.current;\n        \n    },\n    \n    set: function (subject) {\n        if (!string(subject)) {\n            throw new Error(\"Invalid String subject parameter.\");\n        }\n        \n        this.reset();\n        this.subject = subject;\n        this.ready = true;\n        \n\n    },\n    \n    next: function () {\n        var me = this,\n            actions = me.actions,\n            isNumber = number,\n            completed = me.completed,\n            returns = false;\n        var state, params, result, ref, current;\n\n        if (!me.ready) {\n            throw new Error(\"Iterator is not yet ready, nothing to Parse.\");\n        }\n\n        // reset current\n        if (!completed) {\n            delete me.current;\n        }\n        \n        for (; !completed;) {\n            \n            state = me.state;\n            params = me.params;\n            \n            // check if it action can be transitioned\n            if (!(state in me)) {\n                throw new Error(\"No handler found for state \" + state);\n            }\n            \n            // handle transition\n            result = me[state](params);\n            returns = me.returns;\n            delete me.returns;\n            current = me.current;\n            completed = me.completed;\n            \n            // break on error\n            if (me.error) {\n                break;\n            }\n            \n            // after transition, may error caught or successfully completed\n            if (!completed) {\n                \n                // accepts number result\n                if (!isNumber(result)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                    \n                // can transition to next state\n                ref = actions[state];\n                \n                if (!(result in ref)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                \n                me.state = ref[result];\n            }\n            \n            // return params\n            if (returns === true) {\n                return current;\n            }\n            \n            \n        }\n        \n        return me.error || !completed ? false : null;\n        \n    }\n};\n\nexport default BaseIterator;\n","'use strict';\n\nimport {\n            string,\n            method\n        } from \"libcore\";\n\nimport BaseIterator from \"./iterator/base.js\";\n        \nvar defaultIteratorName = \"base\",\n    ITERATORS = {};\n\nexport\n    function register(name, Class) {\n        var Base = BaseIterator;\n        \n        if (!string(name)) {\n            throw new Error(\"Invalid iterator name parameter.\");\n        }\n        \n        if (!method(Class) ||\n            (Class !== Base && !(Class.prototype instanceof Base))) {\n            throw new Error(\"Invalid iterator Class parameter.\");\n        }\n        \n        ITERATORS[':' + name] = Class;\n        \n        return true;\n    }\n\nexport\n    function get(name) {\n        var list = ITERATORS;\n        \n        if (string(name)) {\n            name = ':' + name;\n            if (name in list) {\n                return list[name];\n            }\n        }\n        \n        return null;\n    }\n\nexport {\n            defaultIteratorName as defaultIterator,\n            BaseIterator as Base\n        };\n\nregister(defaultIteratorName, BaseIterator);\n\n\n","'use strict';\n\nimport {\n            string,\n            object,\n            array\n\n        } from \"libcore\";\n\nimport Tokenizer from \"libcore-tokenizer\";\n\nimport StateMap from \"./state/map.js\";\n\nimport builder from \"./state/builder.js\";\n\nimport {\n            get as iteratorGet,\n            defaultIterator\n        } from \"./iterator.js\";\n\nvar debugMode = false;\n\nfunction Parser(root, definition, exclude) {\n    \n    this.tokenizer = new Tokenizer();\n    this.map = new StateMap(debugMode);\n    \n    if (arguments.length) {\n        this.define(root, definition, exclude);\n    }\n}\n\n\nParser.prototype = {\n    subject: '',\n    tokenizer: null,\n    map: null,\n    ready: false,\n    constructor: Parser,\n    \n    iterator: function (name) {\n        var get = iteratorGet;\n        var Iterator;\n        \n        if (arguments.length) {\n            Iterator = get(name);\n            if (!Iterator) {\n                throw new Error(\"Invalid iterator name parameter.\");\n            }\n        }\n        else {\n            Iterator = get(defaultIterator);\n        }\n        \n        return new Iterator(this);\n    },\n    \n    define: function (root, definition, exclude) {\n        var isArray = array;\n        var ready;\n        \n        if (!isArray(exclude)) {\n            exclude = [];\n        }\n        \n        if (!string(root)) {\n            throw new Error(\"Invalid root grammar rule parameter.\");\n        }\n        \n        if (!isArray(definition)) {\n            throw new Error(\"Invalid grammar rules definition parameter\");\n        }\n        \n        \n        this.ready = ready = builder(root,\n                                    this.map,\n                                    this.tokenizer,\n                                    definition,\n                                    exclude);\n        \n        return ready;\n\n    },\n    \n    fromJSON: function (json) {\n        var isObject = object;\n        var tokenMap;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\"Invalid JSON String json parameter.\");\n            }\n        }\n        \n        if (!isObject(json)) {\n            throw new Error(\"Invalid Object json parameter.\");\n        }\n        \n        tokenMap = json.tokens;\n        \n        if (!isObject(tokenMap)) {\n            throw new Error('Invalid \"tokens\" property of json parameter.');\n        }\n        \n        this.tokenizer.fromJSON(tokenMap);\n        this.map.importStates(json);\n        \n        return this;\n        \n    },\n    \n    toJSON: function () {\n        return JSON.stringify(this.toObject());\n    },\n    \n    toObject: function () {\n        var object;\n        \n        if (!this.ready) {\n            throw new Error(\"Grammar rules is not yet defined.\");\n        }\n        \n        object = this.map.toObject();\n        object.tokens = this.tokenizer.toObject();\n        \n        return object;\n    },\n    \n    parse: function (subject, reducer, iterator) {\n        var isString = string,\n            rpn = [],\n            rl = 0;\n        var lexeme, name, value;\n        \n        if (!isString(subject)) {\n            throw new Error(\"Invalid string subject parameter\");\n        }\n        \n        iterator = isString(iterator) ?\n                        this.iterator(iterator) :\n                        this.iterator();\n        \n        if (!iterator) {\n            throw new Error(\"Invalid Iterator parameter.\");\n        }\n        \n        if (!object(reducer)) {\n            reducer = {};\n        }\n        \n        iterator.set(subject);\n        \n        for (lexeme = iterator.next(); lexeme; lexeme = iterator.next()) {\n            rpn[rl++] = lexeme;\n            \n            name = lexeme.name;\n            if (name in reducer) {\n                value = reducer[name](name, lexeme.value, lexeme);\n                \n                if (typeof value !== \"undefined\") {\n                    lexeme.value = value;\n                }\n                else if (lexeme.params !== 0) {\n                    lexeme.value = null;\n                }\n                \n            }\n            \n        }\n        \n        return iterator.error ? false : rpn;\n        \n    }\n};\n\n\nexport default Parser;\n\nexport\n    function debug(isDebugMode) {\n        debugMode = isDebugMode !== false;\n    }\n","'use strict';\n\nimport {\n            string,\n            object\n        } from \"libcore\";\n        \nimport Parser,\n        { debug } from \"./parser.js\";\n\nexport {\n            debug,\n            Parser\n        };\n\nexport {\n            Base as Iterator,\n            register as registerIterator\n        } from \"./iterator.js\";\n\nexport\n    function define(root, definitions, exclusions) {\n        return new Parser(root, definitions, exclusions);\n    }\n\nexport\n    function load(json) {\n        var parser;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\n                    \"Unable to load from invalid json JSON String parameter: \" +\n                    e.toString());\n            }\n        }\n        else if (!object(json)) {\n            throw new Error(\"Unable to load from invalid json Object parameter.\");\n        }\n        \n        parser = new Parser();\n        \n        try {\n            parser.fromJSON(json);\n        }\n        catch (e) {\n            throw new Error(e);\n        }\n        \n        return parser;\n    }\nexport\n    function isParser(parser) {\n        return parser instanceof Parser;\n    }\n\n\n\n\n// integrate to libcore\n//module.exports = libcore.lalr = {\n//    Parser: Parser,\n//    Iterator: iteratorManager.Base,\n//    isParser: isParser,\n//    define: define,\n//    load: load,\n//    registerIterator: iteratorManager.register\n//};"],"names":["StateMap","debug","states","this","stateGen","symbolGen","reduceGen","lookup","symbol","start","ends","exclude","finalized","rawStates","reduceLookup","reducers","debugMode","setRoot","endSymbol","generateSymbol","endToken","isTerminal","name","NONTERMINAL_RE","test","defineTerminals","registry","definitions","c","l","terminal","isRegex","regex","length","Error","registerTerminal","defineRules","rl","rule","lexeme","ruleMask","terminals","isTerminalToken","isString","string","isArray","array","isTerm","terminalExist","source","map","registerRule","State","id","items","end","tokens","pointers","List","define","list","item","token","total","stateBefore","state","StateClass","productionStatesIndex","productions","closureDefinitions","closureItems","stateDefineQueue","defineState","production","augmentedRoot","sl","createClosure","toString","push","first","shift","containsItems","after","setEnd","pointTo","createState","createPointer","setReduceState","Registry","tokenizer","ruleLookup","terminalLookup","stateTagIdGen","stateTagId","stateTagIdLookup","build","root","definition","excludes","defTerminal","defRule","terminalDefinition","reset","splice","lookupSymbol","setExcludes","Lexeme","type","useType","BaseIterator","parser","object","register","Class","Base","method","prototype","ITERATORS","get","Parser","Tokenizer","arguments","isDebugMode","exclusions","load","json","JSON","parse","e","fromJSON","isParser","constructor","target","symbols","access","generateReduceId","params","ruleIndex","all","lookupReducer","current","finalize","importStates","isObject","toObject","has","contains","len","exportStates","stringify","subject","mylen","myItems","mainLoop","targetState","names","last","pop","startRule","rules","hashState","lookupState","hashLexeme","lookupLexeme","mask","before","slice","join","additional","productionItems","created","processed","tl","apply","TYPE","nonterminal","compound","value","reduceCount","from","to","parent","next","previous","types","returns","ready","completed","error","actions",":start","0","1",":tokenize","2","3",":shift",":reduce",":fail",":success","me","nextTokenIndex","ref","literal","pstate","tokenize","isAcceptableToken","buffer","litem","bl","reduce","endIndex","values","update","cursor","complete","set","result","isNumber","number","iterator","Iterator","iteratorGet","builder","tokenMap","toJSON","reducer","rpn"],"mappings":"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"}