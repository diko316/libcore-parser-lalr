{"version":3,"file":"libcore-parser-lalr.min.js","sources":["../src/state/map.js","../src/helper.js","../src/state/pointer.js","../src/state/item.js","../src/state/define.js","../src/state/builder.js","../src/lexeme.js","../src/iterator/base.js","../src/iterator.js","../src/parser.js","../src/all.js"],"sourcesContent":["'use strict';\n\n\nimport {\n            string,\n            object,\n            array\n            \n        } from \"libcore\";\n\nfunction StateMap() {\n    this.reset();\n}\n\n\nStateMap.prototype = {\n    stateGen: 0,\n    rawStates: null,\n    \n    constructor: StateMap,\n    \n    generateState: function () {\n        var id = 's' + (++this.stateGen);\n        this.states[id] = {};\n        return id;\n    },\n    \n    setAnchorState: function (state) {\n        var anchors = this.anchors;\n        \n        if (!(state in anchors)) {\n            this.anchors[state] = true;\n        }\n    },\n    \n    setReduceState: function (state, name, params, ruleIndex) {\n        var ends = this.ends;\n        var current;\n        \n        if (state in ends) {\n            current = ends[state];\n            if (current[0] !== name || current[1] !== params) {\n                throw new Error(\"Reduce conflict found \" +\n                                current[0] + ' ! <- ' + name);\n            }\n        }\n        else {\n            ends[state] = [name, params, ruleIndex];\n        }\n        \n    },\n    \n    reset: function () {\n        var start = '$start',\n            states = {};\n        \n        states[start] = {};\n        this.root = '$end';\n        this.start = start;\n        this.states = states;\n        this.anchors = {};\n        this.ends = {};\n        this.exclude = {};\n        this.finalized = false;\n        this.rawStates = [];\n    },\n\n    finalize: function() {\n        var list = this.rawStates;\n        var c, l;\n\n        if (!this.finalized && list) {\n            this.finalized = true;\n\n            for (c = -1, l = list.length; l--;) {\n                list[++c].finalize();\n            }\n\n            // remove raw states\n            list.length = 0;\n        }\n        \n        return this.finalized;\n    },\n    \n    setExcludes: function (exclude) {\n        var current = this.exclude;\n        var c, l;\n        \n        if (array(exclude)) {\n            for (c = -1, l = exclude.length; l--;) {\n                current[exclude[++c]] = true;\n            }\n        }\n    },\n    \n    importStates: function (definition) {\n        var isObject = object,\n            isString = string;\n        var start, states, anchors, ends, root, exclude;\n        \n        if (!isObject(definition)) {\n            throw new Error(\"Invalid Object definition parameter.\");\n        }\n        \n        states = definition.states;\n        if (!isObject(states)) {\n            throw new Error(\n                        'Invalid \"states\" Object in definition parameter.');\n        }\n        \n        root = definition.root;\n        if (!isString(root)) {\n            throw new Error(\n                        'Invalid \"root\" grammar rule in definition parameter.');\n        }\n        \n        start = definition.start;\n        if (!isString(start) || !(start in states)) {\n            throw new Error(\n                        'Invalid \"start\" state in definition parameter.');\n        }\n        \n        anchors = definition.anchors;\n        if (!isObject(anchors)) {\n            throw new Error('Invalid \"anchors\" states in definition parameter.');\n        }\n        \n        ends = definition.ends;\n        if (!isObject(anchors)) {\n            throw new Error('Invalid \"ends\" states in definition parameter.');\n        }\n\n        exclude = definition.exclude;\n        if (!isObject(exclude)) {\n            throw new Error('Invalid \"exclude\" token in definition parameter.');\n        }\n        \n        this.root = root;\n        this.start = start;\n        this.states = states;\n        this.anchors = anchors;\n        this.ends = ends;\n        this.exclude = exclude;\n        \n        return true;\n    },\n    \n    toObject: function () {\n        return {\n                root: this.root,\n                start: this.start,\n                states: this.states,\n                anchors: this.anchors,\n                ends: this.ends,\n                exclude: this.exclude\n            };\n    },\n    \n    exportStates: function (json) {\n        var current = this.toObject();\n            \n        if (json === true) {\n            try {\n                return JSON.stringify(current);\n            }\n            catch (e) {\n                return null;\n            }\n        }\n        \n        return current;\n    }\n    \n    \n};\n\n\nexport default StateMap;","'use strict';\n\nfunction empty() {\n}\n\nexport\n    function clone(obj) {\n        var E = empty;\n        E.prototype = obj;\n        return new E();\n    }\n\n","'use strict';\n\n\nfunction Pointer(lexeme, state) {\n\n    this.item = lexeme;\n\n    // bind\n    this.to = state;\n\n}\n\nPointer.prototype = {\n    constructor: Pointer,\n    next: null,\n    item: null,\n    to: null\n\n};\n\n\nexport default Pointer;","'use strict';\n\nimport { clone } from \"../helper.js\";\n\nimport Pointer from \"./pointer.js\";\n\nfunction Item(id, map) {\n    var list = map.rawStates;\n    \n    this.map = map;\n    this.state = id = id || map.generateState();\n    this.base = this;\n    this.watched = [];\n    this.reduceList = [];\n\n    // register as raw state\n    list[list.length] = this;\n\n}\n\nItem.prototype = {\n    state: null,\n    constructor: Item,\n    nextInQueue: null,\n    parent: null,\n    map: null,\n    pointer: null,\n    watched: null,\n    contextPointer: null,\n    reduceList: null,\n    lexeme: \"$end\",\n    recursion: {},\n    finalized: false,\n\n    getRecursionItem: function (ruleId) {\n        var recursion = this.recursion;\n\n        return ruleId in recursion ? recursion[ruleId] : null;\n\n    },\n\n    insertNextQueue: function (item) {\n        var after = this.nextInQueue,\n            last = item;\n\n        this.nextInQueue = item;\n\n        // connect last item with my next item\n        for (; last.nextInQueue; last = last.nextInQueue) { }\n\n        last.nextInQueue = after;\n\n    },\n\n    appendQueue: function (item) {\n        var last = this;\n\n        for (; last.nextInQueue; last = last.nextInQueue) { }\n\n        last.nextInQueue = item;\n\n    },\n\n    createRecursion: function (ruleId, lexeme) {\n        var duplicate = clone,\n            item = duplicate(this),\n            recursion = duplicate(this.recursion);\n\n        item.parent = this;\n\n        item.lexeme = lexeme;\n        item.recursion = recursion;\n        recursion[ruleId] = item;\n\n        item.contextPointer =\n            item.nextInQueue = null;\n\n        return item;\n    },\n\n    getPointerItem(lexeme) {\n        var pointer = this.pointer;\n\n        // find from parent and up\n        for (; pointer; pointer = pointer.next) {\n            if (pointer.item === lexeme) {\n                return pointer.to;\n            }\n        }\n\n        return null;\n\n    },\n\n    point: function (lexeme) {\n\n        var Class = Pointer,\n            found = this.getPointerItem(lexeme);\n        var list, c, len, item, has;\n\n        // create if not found\n        if (!found) {\n\n            // create item\n            found = new Item(null, this.map);\n            found.lexeme = lexeme;\n\n            // share recursion\n            found.recursion = this.recursion;\n\n            // create pointer\n            this.onSetPointer(new Class(lexeme, found));\n\n            // populate dependencies\n            list = this.watched;\n\n            for (c = -1, len = list.length; len--;) {\n                item = list[++c];\n                has = item.getPointerItem(lexeme);\n                if (!has) {\n                    item.onSetPointer(new Class(lexeme, found));\n                }\n            }\n        }\n\n        return found;\n\n    },\n\n    watchItem: function (item) {\n        var list = this.watched,\n            Class = Pointer;\n        var pointer, lexeme, found;\n\n        if (item.state !== this.state && list.indexOf(item) === -1) {\n            \n            list[list.length] = item;\n\n            pointer = this.pointer;\n\n            // add current pointers\n            for (; pointer; pointer = pointer.next) {\n                lexeme = pointer.item;\n                found = item.getPointerItem(lexeme);\n\n                if (!found) {\n                    item.onSetPointer(new Class(lexeme, pointer.to));\n                }\n            }\n        }\n        \n    },\n\n    onSetPointer: function (pointer) {\n        var last = this.pointer,\n            context = this.contextPointer;\n        var parent;\n\n        // connect to last item\n        if (last) {\n            // connect last\n            for (; last.next; last = last.next) {}\n            last.next = pointer;\n\n        }\n        // new pointer\n        else {\n            // set base pointer\n            this.base.pointer = pointer;\n        }\n\n        // populate context pointer across parents\n        if (!context) {\n            // populate parent context pointers\n            parent = this;\n            for (; parent; parent = parent.parent) {\n                if (!parent.contextPointer) {\n                    parent.contextPointer = pointer;\n                }\n            }\n        }\n    },\n\n    finalize: function () {\n        var map = this.map,\n            id = this.state,\n            stateObject = map.states[id];\n\n        var list, c, len, item, lexeme;\n\n        // finalize main pointers\n        item = this.pointer;\n\n        for (; item; item = item.next) {\n            lexeme = item.item;\n\n            if (!(lexeme in stateObject)) {\n                stateObject[lexeme] = item.to.state;\n            }\n        }\n\n        // reduce\n        list = this.reduceList;\n        for (c = -1, len = list.length; len--;) {\n            item = list[++c];\n            map.setReduceState(id, item[0], item[1], item[2]);\n        }\n\n    },\n\n    reduce: function (production, params, group) {\n        var list = this.reduceList;\n\n        list[list.length] = [production, params, group];\n\n    }\n\n};\n\nexport default Item;","'use strict';\n\nimport Item from \"./item.js\";\n\nfunction define(grammar, map, exclude) {\n    var STATE_END = 0,\n        STATE_START = 1,\n        STATE_RULE_ITERATE = 2,\n        STATE_RULE_END = 5,\n\n        defineState = STATE_START,\n        ruleIndex = grammar.rules,\n        ruleGroup = grammar.ruleGroup;\n\n    var anchor, production, rule, lexeme, ruleId, params,\n        queue, recursion, pendingRecursion, item;\n\n    map.reset();\n    map.root = grammar.root;\n\n    if (exclude) {\n        map.setExcludes(exclude);\n    }\n\n    queue = new Item(map.start, map);\n    \n    for (; defineState;) {\n\n        switch (defineState) {\n        case STATE_START:\n            if (!queue) {\n                defineState = STATE_END;\n                break;\n            }\n\n            anchor = queue;\n            production = queue.lexeme;\n            \n            rule = ruleIndex[production];\n\n            defineState = STATE_RULE_ITERATE;\n\n            pendingRecursion = null;\n\n        /* falls through */\n        case STATE_RULE_ITERATE:\n            // go to next pending\n            if (!rule) {\n                defineState = STATE_RULE_END;\n                break;\n            }\n            \n            ruleId = rule[0];\n            lexeme = rule[1];\n\n            // go to next rule\n            rule = rule[2];\n\n            // start of rule\n            if (ruleId === false) {\n                params = 0;\n                queue = item = anchor;\n                break;\n            }\n\n            // connect states\n            params++;\n\n            // non-terminal\n            if (lexeme in ruleIndex) {\n\n                // find recursion\n                recursion = item.getRecursionItem(ruleId);\n                \n                // follow recursion\n                if (recursion) {\n\n                    // apply and watch updates\n                    recursion.watchItem(item);\n\n                    // end here\n                    for (; rule && rule[0] !== false; rule = rule[2]) { }\n                    break;\n\n                }\n\n                // create recursion\n                recursion = item.createRecursion(ruleId, lexeme);\n\n                // immediately insert if anchor\n                if (queue === anchor) {\n                    queue.insertNextQueue(recursion);\n\n                }\n                // add to pending\n                else if (pendingRecursion) {\n                    pendingRecursion.appendQueue(recursion);\n                }\n                // first pending recursion\n                else {\n                    pendingRecursion = recursion;\n                }\n                \n            }\n            \n            item = item.point(lexeme);\n\n            // reduce if no more next rules or end of lexer rule\n            if (!rule || rule[0] === false) {\n                item.reduce(production, params, ruleGroup[ruleId]);\n            }\n        \n        break;\n        case STATE_RULE_END:\n\n            // insert pending recursions\n            if (pendingRecursion) {\n                queue.appendQueue(pendingRecursion);\n            }\n\n            // try next pending\n            queue = queue.nextInQueue;\n            defineState = STATE_START;\n\n        break;\n        }\n\n    }\n    \n    \n    // build state map\n    return true;\n    \n}\n\nexport default define;","'use strict';\n\nimport {\n            string,\n            regex,\n            array,\n            contains\n            \n        } from \"libcore\";\n        \nimport defineStates from \"./define.js\";\n        \nvar RULE_NAME_RE = /^([A-Z][a-zA-Z]+(\\_?[a-zA-Z0-9])*|\\$end|\\$)$/;\n\nfunction define(name, rule, grammar, tokenizer) {\n    var rules = grammar.rules,\n        ruleIndex = grammar.ruleIndex,\n        terminal = grammar.terminal,\n        lexIndex = grammar.lexIndex,\n        ruleNames = grammar.ruleNames,\n        ruleNameRe = RULE_NAME_RE,\n        isString = string,\n        isRegex = regex;\n    var l, item, lexemes, token, tokenId, created,\n        prefix, suffix, from, to, current, lexemeId;\n    \n    if (isString(rule) || isRegex(rule)) {\n        rule = [rule];\n    }\n    \n    if (!array(rule)) {\n        throw new Error(\"Invalid grammar rule found in \" + name);\n    }\n    \n    from = to = null;\n    lexemes = [];\n    \n    for (l = rule.length; l--;) {\n        item = rule[l];\n        \n        if (isRegex(item)) {\n            token = item.source;\n            tokenId = '/' + item.source + '/';\n            \n            // register token\n            if (!(tokenId in terminal)) {\n                tokenizer.define([ tokenId, item ]);\n                terminal[tokenId] = tokenId;\n            }\n            \n            item = tokenId;\n        }\n        else if (!isString(item)) {\n            throw new Error(\"Invalid token in grammar rule \" + item);\n        }\n        else if (!ruleNameRe.test(item)) {\n            throw new Error(\"Invalid grammar rule name format: \" + item);\n        }\n        \n        lexemes[l] = item;\n        lexemeId = 'r' + (++grammar.rgenId);\n        lexIndex[lexemeId] = item;\n        created = [lexemeId, item, from];\n        \n        if (!from) {\n            to = created;\n        }\n        from = created;\n\n    }\n    \n    suffix = ' -> ' + lexemes.join(',');\n    prefix = name + ':';\n    tokenId = name + suffix;\n    \n    if (tokenId in ruleIndex) {\n        throw new Error(\"Grammar rule is already defined \" + name + suffix);\n    }\n    else {\n        ruleIndex[tokenId] = true;\n    }\n    \n    if (!(name in rules)) {\n        rules[name] = null;\n        ruleNames[ruleNames.length] = name;\n    }\n    \n    // append\n    from = [false, null, from];\n    current = rules[name];\n    \n    if (current) {\n        to[2] = current;\n    }\n    \n    rules[name] = from;\n    \n    return [from[2][0], to[0]];\n}\n\n\nfunction build(root, stateMap, tokenizer, definitions, exclude) {\n    var isString = string,\n        isArray = array,\n        isRegex = regex,\n        defineRule = define,\n        ruleNameRe = RULE_NAME_RE,\n        ruleNames = [];\n    var c, l, dc, dl, name, definition,\n        rules, grammar, groups, group, index, terminal;\n        \n    name = null;\n    rules = {};\n    grammar = {\n        root: '$' + root,\n        rgenId: 0,\n        ruleNames: ruleNames = [],\n        rules: rules,\n        terminal: terminal = {},\n        lexIndex: index = {},\n        ruleIndex: {},\n        ruleGroup: groups = {}\n    };\n    \n    // augment root\n    definitions.splice(definitions.length,\n                       0,\n                       \"$end\", [\n                            [ root, \"$\" ]\n                        ]);\n\n    for (c = -1, l = definitions.length; l--;) {\n        \n        definition = definitions[++c];\n        \n        if (isString(definition)) {\n            \n            if (!ruleNameRe.test(definition)) {\n                throw new Error(\"Invalid grammar rule name \" + definition);\n            }\n            name = definition;\n        \n        }\n        else if (isArray(definition)) {\n            \n            // do not accept grammar rule if it doesn't have name\n            if (!name) {\n                throw new Error(\"Invalid grammar rules parameter.\");\n            }\n            \n            dc = -1;\n            dl = definition.length;\n            \n            for (; dl--;) {\n                group = defineRule(name,\n                                   definition[++dc],\n                                   grammar,\n                                   tokenizer);\n                // register group\n                groups[group[1]] = name + (dc + 1);\n            }\n\n        }\n        else {\n            throw new Error(\"Invalid item in definitions parameter.\");\n        }\n        \n    }\n    \n    // add excludes\n    if (exclude) {\n        exclude = exclude.slice(0);\n        \n        for (l = exclude.length; l--;) {\n            definition = exclude[l];\n            \n            if (!isRegex(definition)) {\n                throw new Error(\"Invalid exclude token parameter.\");\n            }\n            \n            name = '/' + definition.source + '/';\n            if (!(name in terminal)) {\n                tokenizer.define([ name, definition ]);\n                terminal[name] = name;\n                exclude[l] = name;\n            }\n            else {\n                exclude.splice(l, 1);\n            }\n            \n        }\n        \n    }\n    \n    if (!contains(rules, root)) {\n        throw new Error(\"Invalid root grammar rule parameter.\");\n    }\n    \n    return defineStates(grammar, stateMap, exclude) &&\n            stateMap.finalize();\n\n}\n\nexport default build;\n\n","'use strict';\n\nimport { contains } from \"libcore\";\n\nvar TYPE = {\n        terminal: 1,\n        nonterminal: 2,\n        compound: 3\n    };\n    \n    \n\nfunction Lexeme(type) {\n    this.useType(type);\n}\n\n\nLexeme.prototype = {\n    constructor: Lexeme,\n    name: null,\n    rule: null,\n    value: null,\n    reduceCount: 0,\n    from: 0,\n    to: 0,\n    \n    parent: null,\n    first: null,\n    last: null,\n    next: null,\n    previous: null,\n    \n    useType: function (type) {\n        var types = TYPE;\n        this.type = contains(types, type) ?\n                        types[type] : types.token;\n    }\n};\n\nexport {\n        TYPE as type,\n        Lexeme\n    };\n\nexport default Lexeme;","'use strict';\n\nimport {\n            string,\n            number,\n            object\n        } from \"libcore\";\n        \nimport Lexeme from \"../lexeme.js\";\n\nvar INVALID_STATE_HANDLER = \"Invalid result from state handler\";\n\nfunction BaseIterator(parser) {\n    if (!object(parser)) {\n        throw new Error(\"Invalid parser parameter.\");\n    }\n    \n    this.parser = parser;\n    this.reset();\n    \n    this.start = ':start';\n}\n\n\nBaseIterator.prototype = {\n    constructor: BaseIterator,\n    subject: '',\n    returns: false,\n    current: null,\n    ready: false,\n    completed: false,\n    error: null,\n    \n    actions: {\n        ':start': {\n            0: ':fail',\n            1: ':tokenize'\n            \n        },\n        \n        ':tokenize': {\n            0: ':fail',\n            1: ':tokenize',\n            2: ':shift',\n            3: ':reduce'\n        },\n        \n        ':shift': {\n            0: ':fail',\n            1: ':tokenize'\n        },\n        \n        ':reduce': {\n            0: ':fail',\n            1: ':shift',\n            2: ':reduce',\n            3: ':success'\n        },\n        ':fail': {},\n        ':success': {}\n    },\n    \n    ':start': function () {\n        var me = this;\n        \n        me.params = me.nextTokenIndex;\n        \n        return 1;\n    },\n    \n    ':tokenize': function (from) {\n        var me = this,\n            parser = me.parser,\n            map = parser.map,\n            ends = map.ends,\n            states = map.states,\n            state = me.pstate,\n            token = parser.tokenizer.tokenize(from,\n                                              me.subject);\n            \n        var name, to, ref, lexeme;\n        \n        \n        if (token) {\n            name = token[0];\n            to = token[2];\n            \n            // tokenize again\n            if (!this.isAcceptableToken(token)) {\n                me.params = to;\n                return 1;\n            }\n            \n            lexeme = new Lexeme('terminal');\n            lexeme.name = name;\n            lexeme.value = token[1];\n            lexeme.from = from;\n            lexeme.to = to;\n            \n            me.nextTokenIndex = to;\n            me.params = lexeme;\n            \n            // found shift state\n            ref = states[state];\n            if (name in ref) {\n                return 2;\n            }\n\n        }\n        \n        // can reduce remaining buffer\n        if (me.buffer.length && state in ends) {\n            return 3;\n        }\n        \n        // failed\n        me.params = 'Invalid token';\n        return 0;\n        \n    },\n    \n    ':shift': function (lexeme) {\n        var me = this,\n            buffer = me.buffer,\n            states = me.parser.map.states,\n            state = me.pstate,\n            name = lexeme.name;\n        \n        buffer[buffer.length] = [state, lexeme];\n        \n        me.pstate = states[state][name];\n        me.current = lexeme;\n        me.params = null;\n        \n        // do not return \"$\" token\n        me.returns = name !== \"$\";\n        me.params = me.nextTokenIndex;\n        return 1;\n\n    },\n    \n    ':reduce': function (lexeme) {\n        var me = this,\n            map = me.parser.map,\n            buffer = me.buffer,\n            bl = buffer.length,\n            ends = map.ends,\n            states = map.states,\n            state = me.pstate,\n            reduce = ends[state],\n            name = reduce[0],\n            params = reduce[1],\n            l = params,\n            endIndex = l - 1,\n            created = new Lexeme('nonterminal'),\n            values = [];\n            \n        var litem, item, from, to, ref, last;\n        \n        created.name = name;\n        created.rule = reduce[2];\n        last = null;\n        \n        for (; l--;) {\n            item = buffer[--bl];\n            state = item[0];\n            litem = item[1];\n            \n            // create range\n            from = litem.from;\n            if (l === endIndex) {\n                to = litem.to;\n            }\n            \n            // create connection\n            litem.parent = created;\n             \n            if (last) {\n                last.previous = litem;\n                litem.next = last;\n            }\n            else {\n                created.last = litem;\n            }\n            created.first = last = litem;\n            values[l] = litem.value;\n        }\n        \n        created.value = values;\n        created.from = from;\n        created.to = to;\n        \n        buffer.length = bl;\n        \n        me.current = created;\n        \n        created.reduceCount = params;\n        \n        // only if it ended\n        if (name === '$end') {\n            \n            // end\n            if (bl === 0) {\n                litem = created.first;\n                \n                created.useType('end');\n                created.last = litem;\n                created.value = [litem.value];\n                created.rule = map.root;\n                created.reduceCount = 1;\n                \n                me.params = created;\n                \n                return 3;\n            }\n            else {\n                me.params = 'Failed last reduce';\n                return 0;\n            }\n            \n        }\n        \n        buffer[bl++] = [state, created];\n        me.returns = true;\n        \n        // iterate\n        state = states[state][name];\n        ref = states[state];\n        \n        name = lexeme.name;\n        me.pstate = state;\n        \n        // shift\n        if (name in ref) {\n            return 1;\n        \n        }\n        // reduce\n        else if (state in ends) {\n            return 2;\n        }\n        \n        me.params = 'failed reduce! inside :reduce';\n        return 0;\n        \n    },\n    \n    ':success': function (lexeme) {\n        var me = this;\n        \n        me.completed =\n            me.returns = true;\n\n        me.current = lexeme;\n        \n        return false;\n    },\n    \n    ':fail': function (error) {\n        var me = this;\n        \n        me.error = error;\n        me.completed = true;\n        \n        return false;\n    },\n    \n    isAcceptableToken: function (token) {\n        return !(token[0] in this.parser.map.exclude);\n    },\n    \n    update: function (value) {\n        var me = this,\n            current = me.current;\n        \n        if (!me.error && current) {\n            \n            current.value = value;\n            \n        }\n        \n        return this;\n    },\n    \n    reset: function () {\n        var parser = this.parser;\n        \n        this.nextTokenIndex = 0;\n        this.cursor = 0;\n        this.buffer = [];\n        \n        this.state = this.start;\n        this.pstate = parser.map.start;\n        this.params = null;\n        \n        if (!this.subject) {\n            delete this.ready;\n        }\n        \n        delete this.complete;\n        delete this.error;\n        \n        delete this.returns;\n        delete this.current;\n        \n    },\n    \n    set: function (subject) {\n        if (!string(subject)) {\n            throw new Error(\"Invalid String subject parameter.\");\n        }\n        \n        this.reset();\n        this.subject = subject;\n        this.ready = true;\n        \n\n    },\n    \n    next: function () {\n        var me = this,\n            actions = me.actions,\n            isNumber = number,\n            completed = me.completed,\n            returns = false;\n        var state, params, result, ref, current;\n\n        // reset current\n        if (!completed) {\n            delete me.current;\n        }\n        \n        for (; !completed;) {\n            \n            state = me.state;\n            params = me.params;\n            \n            // check if it action can be transitioned\n            if (!(state in me)) {\n                throw new Error(\"No handler found for state \" + state);\n            }\n            \n            // handle transition\n            result = me[state](params);\n            returns = me.returns;\n            delete me.returns;\n            current = me.current;\n            completed = me.completed;\n            \n            // break on error\n            if (me.error) {\n                break;\n            }\n            \n            // after transition, may error caught or successfully completed\n            if (!completed) {\n                \n                // accepts number result\n                if (!isNumber(result)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                    \n                // can transition to next state\n                ref = actions[state];\n                \n                if (!(result in ref)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                \n                me.state = ref[result];\n            }\n            \n            // return params\n            if (returns === true) {\n                return current;\n            }\n            \n            \n        }\n        \n        return me.error || !completed ? false : null;\n        \n    }\n};\n\nexport default BaseIterator;\n","'use strict';\n\nimport {\n            string,\n            method\n        } from \"libcore\";\n\nimport BaseIterator from \"./iterator/base.js\";\n        \nvar defaultIteratorName = \"base\",\n    ITERATORS = {};\n\nexport\n    function register(name, Class) {\n        var Base = BaseIterator;\n        \n        if (!string(name)) {\n            throw new Error(\"Invalid iterator name parameter.\");\n        }\n        \n        if (!method(Class) ||\n            (Class !== Base && !(Class.prototype instanceof Base))) {\n            throw new Error(\"Invalid iterator Class parameter.\");\n        }\n        \n        ITERATORS[':' + name] = Class;\n        \n        return true;\n    }\n\nexport\n    function get(name) {\n        var list = ITERATORS;\n        \n        if (string(name)) {\n            name = ':' + name;\n            if (name in list) {\n                return list[name];\n            }\n        }\n        \n        return null;\n    }\n\nexport {\n            defaultIteratorName as defaultIterator,\n            BaseIterator as Base\n        };\n\nregister(defaultIteratorName, BaseIterator);\n\n\n","'use strict';\n\nimport {\n            string,\n            object,\n            array\n\n        } from \"libcore\";\n\nimport Tokenizer from \"libcore-tokenizer\";\n\nimport StateMap from \"./state/map.js\";\n\nimport builder from \"./state/builder.js\";\n\nimport {\n            get as iteratorGet,\n            defaultIterator\n        } from \"./iterator.js\";\n\n\nfunction Parser(root, definition, exclude) {\n    \n    this.tokenizer = new Tokenizer();\n    this.map = new StateMap();\n    \n    if (arguments.length) {\n        this.define(root, definition, exclude);\n    }\n}\n\n\nParser.prototype = {\n    subject: '',\n    tokenizer: null,\n    map: null,\n    ready: false,\n    constructor: Parser,\n    \n    iterator: function (name) {\n        var get = iteratorGet;\n        var Iterator;\n        \n        if (arguments.length) {\n            Iterator = get(name);\n            if (!Iterator) {\n                throw new Error(\"Invalid iterator name parameter.\");\n            }\n        }\n        else {\n            Iterator = get(defaultIterator);\n        }\n        \n        return new Iterator(this);\n    },\n    \n    define: function (root, definition, exclude) {\n        var isArray = array;\n        var ready;\n        \n        if (!isArray(exclude)) {\n            exclude = [];\n        }\n        \n        if (!string(root)) {\n            throw new Error(\"Invalid root grammar rule parameter.\");\n        }\n        \n        if (!isArray(definition)) {\n            throw new Error(\"Invalid grammar rules definition parameter\");\n        }\n        \n        \n        this.ready = ready = builder(root,\n                                    this.map,\n                                    this.tokenizer,\n                                    definition,\n                                    exclude);\n        \n        return ready;\n\n    },\n    \n    fromJSON: function (json) {\n        var isObject = object;\n        var tokenMap;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\"Invalid JSON String json parameter.\");\n            }\n        }\n        \n        if (!isObject(json)) {\n            throw new Error(\"Invalid Object json parameter.\");\n        }\n        \n        tokenMap = json.tokens;\n        \n        if (!isObject(tokenMap)) {\n            throw new Error('Invalid \"tokens\" property of json parameter.');\n        }\n        \n        this.tokenizer.fromJSON(tokenMap);\n        this.map.importStates(json);\n        \n        return this;\n        \n    },\n    \n    toJSON: function () {\n        return JSON.stringify(this.toObject());\n    },\n    \n    toObject: function () {\n        var object;\n        \n        if (!this.ready) {\n            throw new Error(\"Grammar rules is not yet defined.\");\n        }\n        \n        object = this.map.toObject();\n        object.tokens = this.tokenizer.toObject();\n        \n        return object;\n    },\n    \n    parse: function (subject, reducer, iterator) {\n        var isString = string,\n            rpn = [],\n            rl = 0;\n        var lexeme, name, value;\n        \n        if (!isString(subject)) {\n            throw new Error(\"Invalid string subject parameter\");\n        }\n        \n        iterator = isString(iterator) ?\n                        this.iterator(iterator) :\n                        this.iterator();\n        \n        if (!iterator) {\n            throw new Error(\"Invalid Iterator parameter.\");\n        }\n        \n        if (!object(reducer)) {\n            reducer = {};\n        }\n        \n        iterator.set(subject);\n        \n        for (lexeme = iterator.next(); lexeme; lexeme = iterator.next()) {\n            rpn[rl++] = lexeme;\n            \n            name = lexeme.name;\n            if (name in reducer) {\n                value = reducer[name](name, lexeme.value, lexeme);\n                \n                if (typeof value !== \"undefined\") {\n                    lexeme.value = value;\n                }\n                else if (lexeme.params !== 0) {\n                    lexeme.value = null;\n                }\n                \n            }\n            \n        }\n        \n        return iterator.error ? false : rpn;\n        \n    }\n};\n\n\nexport default Parser;","'use strict';\n\nimport {\n            string,\n            object\n        } from \"libcore\";\n        \nimport Parser from \"./parser.js\";\n\nexport { Parser };\n\nexport {\n            Base as Iterator,\n            register as registerIterator\n        } from \"./iterator.js\";\n\nexport\n    function define(root, definitions, exclusions) {\n        return new Parser(root, definitions, exclusions);\n    }\n\nexport\n    function load(json) {\n        var parser;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\n                    \"Unable to load from invalid json JSON String parameter: \" +\n                    e.toString());\n            }\n        }\n        else if (!object(json)) {\n            throw new Error(\"Unable to load from invalid json Object parameter.\");\n        }\n        \n        parser = new Parser();\n        \n        try {\n            parser.fromJSON(json);\n        }\n        catch (e) {\n            throw new Error(e);\n        }\n        \n        return parser;\n    }\nexport\n    function isParser(parser) {\n        return parser instanceof Parser;\n    }\n\n\n\n\n// integrate to libcore\n//module.exports = libcore.lalr = {\n//    Parser: Parser,\n//    Iterator: iteratorManager.Base,\n//    isParser: isParser,\n//    define: define,\n//    load: load,\n//    registerIterator: iteratorManager.register\n//};"],"names":["StateMap","this","reset","empty","clone","obj","E","prototype","Pointer","lexeme","state","item","to","Item","id","map","list","rawStates","generateState","base","watched","reduceList","length","define","grammar","exclude","anchor","production","rule","ruleId","params","queue","recursion","pendingRecursion","defineState","ruleIndex","rules","ruleGroup","root","setExcludes","start","getRecursionItem","watchItem","createRecursion","insertNextQueue","appendQueue","point","reduce","nextInQueue","name","tokenizer","l","lexemes","tokenId","created","suffix","from","current","lexemeId","terminal","lexIndex","ruleNames","ruleNameRe","RULE_NAME_RE","isString","string","isRegex","regex","array","Error","source","test","rgenId","join","build","stateMap","definitions","c","dc","dl","definition","groups","isArray","defineRule","splice","slice","contains","defineStates","finalize","Lexeme","type","useType","BaseIterator","parser","object","register","Class","Base","method","ITERATORS","get","Parser","Tokenizer","arguments","exclusions","load","json","JSON","parse","e","toString","fromJSON","isParser","stateGen","constructor","states","setAnchorState","anchors","setReduceState","ends","finalized","importStates","isObject","toObject","exportStates","stringify","next","parent","pointer","contextPointer","after","last","duplicate","getPointerItem","len","found","onSetPointer","indexOf","context","stateObject","group","TYPE","nonterminal","compound","value","reduceCount","first","previous","types","token","subject","returns","ready","completed","error","actions",":start","0","1",":tokenize","2","3",":shift",":reduce",":fail",":success","me","nextTokenIndex","ref","pstate","tokenize","isAcceptableToken","buffer","litem","bl","endIndex","values","update","cursor","complete","set","result","isNumber","number","iterator","Iterator","iteratorGet","builder","tokenMap","tokens","toJSON","reducer","rpn","rl"],"mappings":"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"}