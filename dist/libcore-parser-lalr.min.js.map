{"version":3,"file":"libcore-parser-lalr.min.js","sources":["../src/state/map.js","../src/helper.js","../src/state/pointer.js","../src/state/item.js","../src/state/define.js","../src/state/builder.js","../src/lexeme.js","../src/iterator/base.js","../src/iterator.js","../src/parser.js","../src/all.js"],"sourcesContent":["'use strict';\n\n\nimport {\n            string,\n            object,\n            array,\n            contains\n            \n        } from \"libcore\";\n\nfunction StateMap() {\n    var start = \"$start\",\n        end = \"$end\",\n        tokenEnd = \"$\",\n        states = {};\n\n    this.stateGen =\n        this.symbolGen =\n        this.reduceGen = 0;\n\n    states[start] = {};\n    this.root = end;\n    this.lookup = {};\n    this.symbol = {};\n    this.start = start;\n    this.states = states;\n    this.anchors = {};\n    this.ends = {};\n    this.exclude = {};\n    this.finalized = false;\n    this.rawStates = [];\n\n    this.reduceLookup = {};\n    this.reducers = {};\n\n    this.augmentedRoot = this.generateSymbol(end);\n    this.endSymbol = this.generateSymbol(tokenEnd);\n    this.endToken = tokenEnd;\n\n}\n\n\nStateMap.prototype = {\n    stateGen: 0,\n    rawStates: null,\n    \n    constructor: StateMap,\n    \n    generateState: function () {\n        var id = 's' + (++this.stateGen);\n        this.states[id] = {};\n        return id;\n    },\n\n    generateSymbol: function (name) {\n        var lookup = this.lookup,\n            symbols = this.symbol,\n            access = ':' + name;\n        var id;\n        \n        if (access in lookup) {\n            return lookup[access];\n        }\n    \n        // create symbol\n        id = 's>' + (++this.symbolGen);\n    \n        lookup[access] = id;\n        symbols[id] = name;\n    \n        return id;\n    \n    },\n\n    generateReduceId: function (name, params, ruleIndex) {\n        var lookup = this.reduceLookup,\n            all = this.reducers,\n            access = name + ':' + params + ':' + ruleIndex;\n        var id;\n\n        if (access in lookup) {\n            return lookup[access];\n        }\n\n        id = 'r>' + (++this.reduceGen);\n\n        lookup[access] = id;\n        all[id] = [name, params, ruleIndex];\n\n        return id;\n    },\n\n    lookupReducer: function (id) {\n        var all = this.reducers;\n        \n        if (id in all) {\n            return all[id];\n        }\n\n        return false;\n    },\n\n    lookupSymbol(name) {\n        var symbols = this.symbol;\n\n        if (name in symbols) {\n            return symbols[name];\n        }\n\n        return false;\n\n    },\n    \n    setAnchorState: function (state) {\n        var anchors = this.anchors;\n        \n        if (!(state in anchors)) {\n            this.anchors[state] = true;\n        }\n    },\n    \n    setReduceState: function (state, name, params, ruleIndex) {\n        var ends = this.ends,\n            id = this.generateReduceId(name, params, ruleIndex),\n            all = this.reducers;\n        var current;\n        \n        if (state in ends) {\n            current = all[ends[state]];\n            if (current[0] !== name || current[1] !== params) {\n                throw new Error(\"Reduce conflict found \" +\n                                current[0] + ' ! <- ' + name);\n            }\n        }\n        else {\n            ends[state] = id;\n        }\n        \n    },\n    \n    reset: function () {\n        this.constructor();\n    },\n\n    finalize: function() {\n        var list = this.rawStates;\n        var c, l;\n\n        if (!this.finalized && list) {\n            this.finalized = true;\n\n            for (c = -1, l = list.length; l--;) {\n                list[++c].finalize();\n            }\n\n            // remove raw states\n            list.length = 0;\n\n            // remove lookup\n            delete this.lookup;\n        }\n        \n        return this.finalized;\n    },\n    \n    setExcludes: function (exclude) {\n        var current = this.exclude;\n        var c, l;\n        \n        if (array(exclude)) {\n            for (c = -1, l = exclude.length; l--;) {\n                current[exclude[++c]] = true;\n            }\n        }\n    },\n    \n    importStates: function (definition) {\n        var isObject = object,\n            isString = string;\n        var start, states, anchors, ends, root, exclude, symbol, reducers,\n            list, c, l;\n        \n        if (!isObject(definition)) {\n            throw new Error(\"Invalid Object definition parameter.\");\n        }\n        \n        states = definition.states;\n        if (!isObject(states)) {\n            throw new Error(\n                        'Invalid \"states\" Object in definition parameter.');\n        }\n        \n        root = definition.root;\n        if (!isString(root)) {\n            throw new Error(\n                        'Invalid \"root\" grammar rule in definition parameter.');\n        }\n        \n        start = definition.start;\n        if (!isString(start) || !(start in states)) {\n            throw new Error(\n                        'Invalid \"start\" state in definition parameter.');\n        }\n        \n        anchors = definition.anchors;\n        if (!isObject(anchors)) {\n            throw new Error('Invalid \"anchors\" states in definition parameter.');\n        }\n        \n        ends = definition.ends;\n        if (!isObject(anchors)) {\n            throw new Error('Invalid \"ends\" states in definition parameter.');\n        }\n\n        reducers = definition.reducers;\n        if (!isObject(reducers)) {\n            throw new Error('Invalid production \"reducers\" in definition.');\n        }\n\n        symbol = definition.symbol;\n        if (!isObject(symbol)) {\n            throw new Error('Invalid \"symbol\" map in definition parameter.');\n        }\n\n        list = definition.exclude;\n        if (!array(list)) {\n            throw new Error('Invalid \"exclude\" token in definition parameter.');\n        }\n\n        exclude = {};\n        for (c = -1, l = list.length; l--;) {\n            exclude[list[++c]] = true;\n        }\n        \n        this.root = root;\n        this.start = start;\n        this.states = states;\n        this.anchors = anchors;\n        this.ends = ends;\n        this.reducers = reducers;\n        this.exclude = exclude;\n        this.symbol = symbol;\n        \n        return true;\n    },\n    \n    toObject: function () {\n        var has = contains,\n            exclude = this.exclude,\n            list = [],\n            len = 0;\n        var name;\n\n        // export exclude\n        for (name in exclude) {\n            if (has(exclude, name)) {\n                list[len++] = name;\n            }\n        }\n\n\n        return {\n                root: this.root,\n                start: this.start,\n                states: this.states,\n                anchors: this.anchors,\n                reducers: this.reducers,\n                ends: this.ends,\n                exclude: list,\n                symbol: this.symbol\n            };\n    },\n    \n    exportStates: function (json) {\n        var current = this.toObject();\n            \n        if (json === true) {\n            try {\n                return JSON.stringify(current);\n            }\n            catch (e) {\n                return null;\n            }\n        }\n        \n        return current;\n    }\n    \n    \n};\n\n\nexport default StateMap;","'use strict';\n\nfunction empty() {\n}\n\nexport\n    function clone(obj) {\n        var E = empty;\n        E.prototype = obj;\n        return new E();\n    }\n\n","'use strict';\n\n\nfunction Pointer(lexeme, state) {\n\n    this.item = lexeme;\n\n    // bind\n    this.to = state;\n\n}\n\nPointer.prototype = {\n    constructor: Pointer,\n    next: null,\n    item: null,\n    to: null\n\n};\n\n\nexport default Pointer;","'use strict';\n\nimport { clone } from \"../helper.js\";\n\nimport Pointer from \"./pointer.js\";\n\nfunction Item(id, map) {\n    var list = map.rawStates;\n    \n    this.map = map;\n    this.state = id = id || map.generateState();\n    this.base = this;\n    this.watched = [];\n    this.reduceList = [];\n    this.recursion = {};\n\n    this.references = [];\n\n    // create default\n    this.lexeme = map.augmentedRoot;\n\n    // register as raw state\n    list[list.length] = this;\n\n}\n\nItem.prototype = {\n    state: null,\n    constructor: Item,\n    nextInQueue: null,\n    parent: null,\n    map: null,\n    pointer: null,\n    watched: null,\n    contextPointer: null,\n    reduceList: null,\n    lexeme: null,\n    recursion: null,\n    finalized: false,\n\n    getRecursionItem: function (ruleId) {\n        var recursion = this.recursion;\n\n        return ruleId in recursion ? recursion[ruleId] : null;\n\n    },\n\n    insertNextQueue: function (item) {\n        var after = this.nextInQueue,\n            last = item;\n\n        this.nextInQueue = item;\n\n        // connect last item with my next item\n        for (; last.nextInQueue; last = last.nextInQueue) { }\n\n        last.nextInQueue = after;\n\n    },\n\n    appendQueue: function (item) {\n        var last = this;\n\n        for (; last.nextInQueue; last = last.nextInQueue) { }\n\n        last.nextInQueue = item;\n\n    },\n\n    createRecursion: function (ruleId, lexeme) {\n        var item = clone(this),\n            // common recursion\n            recursion = this.recursion;\n\n        item.parent = this;\n\n        item.lexeme = lexeme;\n        item.recursion = recursion;\n        recursion[ruleId] = item;\n\n        item.contextPointer =\n            item.nextInQueue = null;\n\n        return item;\n    },\n\n    getPointerItem(lexeme) {\n        var pointer = this.pointer;\n\n        // find from parent and up\n        for (; pointer; pointer = pointer.next) {\n            if (pointer.item === lexeme) {\n                return pointer.to;\n            }\n        }\n\n        return null;\n\n    },\n\n    point: function (lexeme) {\n\n        var Class = Pointer,\n            found = this.getPointerItem(lexeme);\n        var list, c, len, item, has;\n\n        // create if not found\n        if (!found) {\n\n            // create item\n            found = new Item(null, this.map);\n            found.lexeme = lexeme;\n\n            // share recursion\n            found.recursion = this.recursion;\n\n            // create pointer\n            this.onSetPointer(new Class(lexeme, found));\n\n            // populate dependencies\n            list = this.watched;\n\n            for (c = -1, len = list.length; len--;) {\n                item = list[++c];\n                has = item.getPointerItem(lexeme);\n                if (!has) {\n                    item.onSetPointer(new Class(lexeme, found));\n                }\n            }\n        }\n\n        return found;\n\n    },\n\n    watchItem: function (item) {\n        var list = this.watched,\n            Class = Pointer;\n        var pointer, lexeme, found;\n\n        if (item.state !== this.state && list.indexOf(item) === -1) {\n            \n            list[list.length] = item;\n\n            pointer = this.pointer;\n\n            // add current pointers\n            for (; pointer; pointer = pointer.next) {\n                lexeme = pointer.item;\n                found = item.getPointerItem(lexeme);\n\n                if (!found) {\n                    item.onSetPointer(new Class(lexeme, pointer.to));\n                }\n            }\n        }\n        \n    },\n\n    onSetPointer: function (pointer) {\n        var last = this.pointer,\n            context = this.contextPointer;\n        var parent;\n\n        // connect to last item\n        if (last) {\n            // connect last\n            for (; last.next; last = last.next) {}\n            last.next = pointer;\n\n        }\n        // new pointer\n        else {\n            // set base pointer\n            this.base.pointer = pointer;\n        }\n\n        // populate context pointer across parents\n        if (!context) {\n            // populate parent context pointers\n            parent = this;\n            for (; parent; parent = parent.parent) {\n                if (!parent.contextPointer) {\n                    parent.contextPointer = pointer;\n                }\n            }\n        }\n    },\n\n    finalize: function () {\n        var map = this.map,\n            id = this.state,\n            stateObject = map.states[id];\n\n        var list, c, len, item, lexeme;\n\n        // finalize main pointers\n        item = this.pointer;\n\n        for (; item; item = item.next) {\n            lexeme = item.item;\n\n            if (!(lexeme in stateObject)) {\n                stateObject[lexeme] = item.to.state;\n            }\n        }\n\n        // reduce\n        list = this.reduceList;\n        for (c = -1, len = list.length; len--;) {\n            item = list[++c];\n            map.setReduceState(id, item[0], item[1], item[2]);\n        }\n\n    },\n\n    reduce: function (production, params, group) {\n        var list = this.reduceList;\n\n        list[list.length] = [production, params, group];\n\n    }\n\n};\n\nexport default Item;","'use strict';\n\nimport Item from \"./item.js\";\n\nfunction define(grammar, map, exclude) {\n    var STATE_END = 0,\n        STATE_START = 1,\n        STATE_RULE_ITERATE = 2,\n        STATE_RULE_END = 5,\n\n        defineState = STATE_START,\n        ruleIndex = grammar.rules,\n        ruleGroup = grammar.ruleGroup;\n\n    var anchor, production, rule, lexeme, ruleId, params,\n        queue, recursion, pendingRecursion, item;\n\n\n    if (exclude) {\n        map.setExcludes(exclude);\n    }\n\n    queue = new Item(map.start, map);\n    \n    for (; defineState;) {\n\n        switch (defineState) {\n        case STATE_START:\n            if (!queue) {\n                defineState = STATE_END;\n                break;\n            }\n\n            anchor = queue;\n            production = queue.lexeme;\n            \n            rule = ruleIndex[production];\n\n            defineState = STATE_RULE_ITERATE;\n\n            pendingRecursion = null;\n\n        /* falls through */\n        case STATE_RULE_ITERATE:\n            // go to next pending\n            if (!rule) {\n                defineState = STATE_RULE_END;\n                break;\n            }\n            \n            ruleId = rule[0];\n            lexeme = rule[1];\n\n            // go to next rule\n            rule = rule[2];\n\n            // start of rule\n            if (ruleId === false) {\n                params = 0;\n                queue = item = anchor;\n                break;\n            }\n\n            // connect states\n            params++;\n\n            // non-terminal\n            if (lexeme in ruleIndex) {\n\n                // find recursion\n                recursion = item.getRecursionItem(ruleId);\n                \n                // follow recursion\n                if (recursion) {\n\n                    // apply and watch updates\n                    recursion.watchItem(item);\n\n                    // end here\n                    for (; rule && rule[0] !== false; rule = rule[2]) { }\n                    break;\n\n                }\n\n                // create recursion\n                recursion = item.createRecursion(ruleId, lexeme);\n\n                // immediately insert if anchor\n                if (queue === anchor) {\n                    queue.insertNextQueue(recursion);\n\n                }\n                // add to pending\n                else if (pendingRecursion) {\n                    pendingRecursion.appendQueue(recursion);\n                }\n                // first pending recursion\n                else {\n                    pendingRecursion = recursion;\n                }\n                \n            }\n            \n            item = item.point(lexeme);\n\n            // reduce if no more next rules or end of lexer rule\n            if (!rule || rule[0] === false) {\n                item.reduce(production, params, ruleGroup[ruleId]);\n            }\n        \n        break;\n        case STATE_RULE_END:\n\n            // insert pending recursions\n            if (pendingRecursion) {\n                queue.appendQueue(pendingRecursion);\n            }\n\n            // try next pending\n            queue = queue.nextInQueue;\n            defineState = STATE_START;\n\n        break;\n        }\n\n    }\n    \n    // build state map\n    return true;\n    \n}\n\nexport default define;","'use strict';\n\nimport {\n            string,\n            regex,\n            array,\n            contains\n            \n        } from \"libcore\";\n        \nimport defineStates from \"./define.js\";\n        \nvar RULE_NAME_RE = /^([A-Z][a-zA-Z]+(\\_?[a-zA-Z0-9])*|\\$end|\\$)$/;\n\n\nfunction registerToken(grammar, definition, name) {\n    var terminal = grammar.terminal,\n        alias = grammar.tokenAlias,\n        tokens = grammar.tokens,\n        map = grammar.map,\n        pendingTerminals = grammar.pendingTerminals;\n    var reference, len;\n\n    reference = map.generateSymbol('/' + definition.source + '/'); \n    if (!name) {\n        name = reference;\n    }\n    \n    // register alias as terminal\n    if (!(reference in alias)) {\n        alias[reference] = name;\n        len = tokens.length;\n        tokens[len++] = name;\n        tokens[len++] = definition;\n\n    }\n    else if (alias[reference] !== name) {\n        throw new Error(\"Token definition \" + definition.source +\n                        \" is a duplicate of \" +\n                        map.lookupSymbol(alias[reference]));\n    }\n    \n    if (!(name in terminal)) {\n        terminal[name] = reference;\n        \n        if (pendingTerminals.indexOf(name) === -1) {\n            pendingTerminals[pendingTerminals.length] = name;\n        }\n    }\n\n    return [name, reference];\n}\n\nfunction defineTerminal(name, rule, grammar) {\n    var map = grammar.map,\n        setToken = registerToken,\n        isRegex = regex,\n        errorMessage = \"Invalid terminal definitions in \" +\n                        map.lookupSymbol(name);\n\n    var c, l, item;\n\n    if (isRegex(rule)) {\n        rule = [rule];\n    }\n\n    if (!array(rule)) {\n        throw new Error(errorMessage);\n    }\n\n    for (c = -1, l = rule.length; l--;) {\n        item = rule[++c];\n\n        if (isRegex(item)) {\n            setToken(grammar, item, name);\n        }\n        else {\n            throw new Error(errorMessage);\n        }\n    }\n}\n\nfunction defineRule(name, rule, grammar) {\n    var rules = grammar.rules,\n        ruleIndex = grammar.ruleIndex,\n        lexIndex = grammar.lexIndex,\n        ruleNames = grammar.ruleNames,\n        ruleNameRe = RULE_NAME_RE,\n        map = grammar.map,\n        pendingTerminals = grammar.pendingTerminals,\n        registerTerminal = registerToken,\n        isString = string,\n        isRegex = regex;\n    var l, item, lexemes, token, created,\n        prefix, suffix, from, to, current, lexemeId;\n    \n    if (isString(rule) || isRegex(rule)) {\n        rule = [rule];\n    }\n    \n    if (!array(rule)) {\n        throw new Error(\"Invalid grammar rule found in \" + name);\n    }\n    \n    from = to = null;\n    lexemes = [];\n    \n    for (l = rule.length; l--;) {\n        item = rule[l];\n\n        if (isRegex(item)) {\n            token = registerTerminal(grammar, item);\n            item = token[0];\n\n        }\n        else if (!isString(item)) {\n            throw new Error(\"Invalid token in grammar rule \" + item);\n        }\n        // terminal\n        else if (!ruleNameRe.test(item)) {\n\n            item = map.generateSymbol(item);\n\n            if (pendingTerminals.indexOf(item) === -1) {\n                pendingTerminals[pendingTerminals.length] = item;\n            }\n\n        }\n        else {\n            item = map.generateSymbol(item);\n        }\n        \n        lexemes[l] = item;\n        lexemeId = 'r' + (++grammar.rgenId);\n        lexIndex[lexemeId] = item;\n        created = [lexemeId, item, from];\n        \n        if (!from) {\n            to = created;\n        }\n        from = created;\n\n    }\n    \n    suffix = ' -> ' + lexemes.join(',');\n    prefix = name + ':';\n    token = name + suffix;\n    \n    if (token in ruleIndex) {\n        throw new Error(\"Grammar rule is already defined \" + name + suffix);\n    }\n    else {\n        ruleIndex[token] = true;\n    }\n    \n    if (!(name in rules)) {\n        rules[name] = null;\n        ruleNames[ruleNames.length] = name;\n    }\n    \n    // append\n    from = [false, null, from];\n    current = rules[name];\n    \n    if (current) {\n        to[2] = current;\n    }\n    \n    rules[name] = from;\n    \n    return [from[2][0], to[0]];\n}\n\n\nfunction build(root, stateMap, tokenizer, definitions, exclude) {\n    var isString = string,\n        isArray = array,\n        isRegex = regex,\n        registerRule = defineRule,\n        registerTerminal = defineTerminal,\n        defineToken = registerToken,\n        rules = {},\n        ruleNameRe = RULE_NAME_RE,\n        ruleNames = [],\n        grammarRoot = \"$\" + root,\n        name = null,\n        tokens = [],\n        pendingTerminals = [],\n        isTerminalName = false;\n    var c, l, dc, dl, definition, pl, original,\n        grammar, groups, group, index, terminal,\n        callback;\n\n    stateMap.reset();\n    \n    stateMap.root = stateMap.generateSymbol(grammarRoot);\n\n    grammar = {\n        root: grammarRoot,\n        rgenId: 0,\n        map: stateMap,\n        ruleNames: ruleNames = [],\n        rules: rules,\n        terminal: terminal = {},\n        tokens: tokens,\n        tokenAlias: {},\n        pendingTerminals: pendingTerminals,\n        lexIndex: index = {},\n        ruleIndex: {},\n        ruleGroup: groups = {}\n    };\n    \n    // augment root\n    definitions.splice(definitions.length,\n                       0,\n                       stateMap.lookupSymbol(stateMap.augmentedRoot),\n                        [[ root,\n                            stateMap.lookupSymbol(stateMap.endSymbol)]]);\n\n    for (c = -1, l = definitions.length; l--;) {\n        \n        definition = definitions[++c];\n        \n        if (isString(definition)) {\n\n            isTerminalName = !ruleNameRe.test(definition);\n            name = stateMap.generateSymbol(definition);\n            original = definition;\n        \n        }\n        else if (isArray(definition)) {\n            \n            // do not accept grammar rule if it doesn't have name\n            if (!name) {\n                throw new Error(\"Invalid grammar rules parameter.\");\n            }\n            \n            dc = -1;\n            dl = definition.length;\n\n            callback = isTerminalName ? registerTerminal : registerRule;\n            \n            for (; dl--;) {\n\n                group = callback(name, definition[++dc], grammar);\n\n                // register group\n                if (!isTerminalName) {\n                    groups[group[1]] = stateMap.generateSymbol((dc + 1) +\n                                                                ':' +\n                                                                original);\n                }\n\n            }\n\n        }\n        else {\n            throw new Error(\"Invalid item in definitions parameter.\");\n        }\n        \n    }\n    \n    // add excludes\n    if (exclude) {\n        exclude = exclude.slice(0);\n        pl = pendingTerminals.length;\n        \n        for (l = exclude.length; l--;) {\n            definition = exclude[l];\n\n            if (isString(definition)) {\n                name = stateMap.generateSymbol(definition);\n\n                if (pendingTerminals.indexOf(name) === -1) {\n                    pendingTerminals[pl++] = name;\n                }\n                \n            }\n            else if (isRegex(definition)) {\n                definition = defineToken(grammar, definition, null, true);\n                name = definition[0];\n            }\n            else {\n                throw new Error(\"Invalid exclude token parameter.\");\n            }\n\n            // rename!\n            exclude[l] = name;\n        }\n        \n    }\n\n    // resolve pending terminals\n    pl = pendingTerminals.length;\n    for (; pl--;) {\n        name = pendingTerminals[pl];\n\n        if (!(name in terminal)) {\n            throw new Error(\"Terminal is not defined \",\n                            stateMap.lookupSymbol(name));\n        }\n    }\n    pendingTerminals.length = 0;\n\n    // register\n    if (tokens.length) {\n        tokenizer.define(tokens);\n    }\n\n    \n    if (!contains(rules, stateMap.generateSymbol(root))) {\n        throw new Error(\"Invalid root grammar rule parameter.\");\n    }\n    \n    return defineStates(grammar, stateMap, exclude) &&\n            stateMap.finalize();\n\n}\n\nexport default build;\n\n","'use strict';\n\nimport { contains } from \"libcore\";\n\nvar TYPE = {\n        terminal: 1,\n        nonterminal: 2,\n        compound: 3,\n        end: 4\n    };\n    \n    \n\nfunction Lexeme(type) {\n    this.terminal = false;\n    this.useType(type);\n}\n\n\nLexeme.prototype = {\n    constructor: Lexeme,\n    name: null,\n    rule: null,\n    value: null,\n    reduceCount: 0,\n    from: 0,\n    to: 0,\n    \n    parent: null,\n    first: null,\n    last: null,\n    next: null,\n    previous: null,\n    terminal: false,\n    \n    useType: function (type) {\n        var types = TYPE;\n        this.type = type = contains(types, type) ?\n                                types[type] : types.token;\n        if (type === TYPE.terminal) {\n            this.terminal = true;\n        }\n    }\n};\n\nexport {\n        TYPE as type,\n        Lexeme\n    };\n\nexport default Lexeme;","'use strict';\n\nimport {\n            string,\n            number,\n            object\n        } from \"libcore\";\n        \nimport Lexeme from \"../lexeme.js\";\n\nvar INVALID_STATE_HANDLER = \"Invalid result from state handler\";\n\nfunction BaseIterator(parser) {\n    if (!object(parser)) {\n        throw new Error(\"Invalid parser parameter.\");\n    }\n    \n    this.parser = parser;\n    this.reset();\n    \n    this.start = ':start';\n}\n\n\nBaseIterator.prototype = {\n    constructor: BaseIterator,\n    subject: '',\n    returns: false,\n    current: null,\n    ready: false,\n    completed: false,\n    error: null,\n    \n    actions: {\n        ':start': {\n            0: ':fail',\n            1: ':tokenize'\n            \n        },\n        \n        ':tokenize': {\n            0: ':fail',\n            1: ':tokenize',\n            2: ':shift',\n            3: ':reduce'\n        },\n        \n        ':shift': {\n            0: ':fail',\n            1: ':tokenize'\n        },\n        \n        ':reduce': {\n            0: ':fail',\n            1: ':shift',\n            2: ':reduce',\n            3: ':success'\n        },\n        ':fail': {},\n        ':success': {}\n    },\n    \n    ':start': function () {\n        var me = this;\n        \n        me.params = me.nextTokenIndex;\n        \n        return 1;\n    },\n    \n    ':tokenize': function (from) {\n        var me = this,\n            parser = me.parser,\n            map = parser.map,\n            ends = map.ends,\n            states = map.states,\n            state = me.pstate,\n            token = parser.tokenizer.tokenize(from,\n                                              me.subject),\n            endToken = map.endToken;\n            \n        var name, to, ref, lexeme, literal;\n        \n        if (token) {\n            name = token[0];\n            to = token[2];\n            \n            // tokenize again\n            if (!this.isAcceptableToken(token)) {\n                me.params = to;\n                return 1;\n            }\n            \n            lexeme = new Lexeme('terminal');\n\n            // end token is not symbolized!\n            literal = name;\n            if (name === endToken) {\n                name = map.endSymbol;\n            }\n            else {\n                literal = map.symbol[name];\n            }\n            \n            lexeme.name = literal;\n            lexeme.symbol = name;\n            lexeme.value = token[1];\n            lexeme.from = from;\n            lexeme.to = to;\n            \n            me.nextTokenIndex = to;\n            me.params = lexeme;\n            \n            // found shift state\n            ref = states[state];\n            if (name in ref) {\n                return 2;\n            }\n\n        }\n        \n        // can reduce remaining buffer\n        if (me.buffer.length && state in ends) {\n            return 3;\n        }\n        \n        // failed\n        me.params = 'Invalid token';\n        return 0;\n        \n    },\n    \n    ':shift': function (lexeme) {\n        var me = this,\n            buffer = me.buffer,\n            map = me.parser.map,\n            states = map.states,\n            state = me.pstate,\n            name = lexeme.symbol;\n        \n        buffer[buffer.length] = [state, lexeme];\n        \n        me.pstate = states[state][name];\n        me.current = lexeme;\n        me.params = null;\n        \n        // do not return \"$\" token\n        me.returns = name !== map.endSymbol;\n        me.params = me.nextTokenIndex;\n        \n        return 1;\n\n    },\n    \n    ':reduce': function (lexeme) {\n        var me = this,\n            map = me.parser.map,\n            buffer = me.buffer,\n            bl = buffer.length,\n            ends = map.ends,\n            states = map.states,\n            lookup = map.symbol,\n            state = me.pstate,\n            reduce = map.lookupReducer(ends[state]),\n            name = reduce[0],\n            params = reduce[1],\n            l = params,\n            endIndex = l - 1,\n            created = new Lexeme('nonterminal'),\n            values = [];\n            \n        var litem, item, from, to, ref, last;\n        \n        created.name = lookup[name];\n        created.symbol = name;\n        created.rule = lookup[reduce[2]];\n        last = null;\n        \n        for (; l--;) {\n            item = buffer[--bl];\n            state = item[0];\n            litem = item[1];\n            \n            // create range\n            from = litem.from;\n            if (l === endIndex) {\n                to = litem.to;\n            }\n            \n            // create connection\n            litem.parent = created;\n             \n            if (last) {\n                last.previous = litem;\n                litem.next = last;\n            }\n            else {\n                created.last = litem;\n            }\n            created.first = last = litem;\n            values[l] = litem.value;\n        }\n        \n        created.value = values;\n        created.from = from;\n        created.to = to;\n        \n        buffer.length = bl;\n        \n        me.current = created;\n        \n        created.reduceCount = params;\n        \n        // only if it ended\n        if (name === map.augmentedRoot) {\n            \n            // end\n            if (bl === 0) {\n                litem = created.first;\n                \n                created.useType('end');\n                created.last = litem;\n                created.value = [litem.value];\n                created.rule = lookup[map.root];\n                created.reduceCount = 1;\n                \n                me.params = created;\n                \n                return 3;\n            }\n            else {\n                me.params = 'Failed last reduce';\n                return 0;\n            }\n            \n        }\n        \n        buffer[bl++] = [state, created];\n        me.returns = true;\n        \n        // iterate\n        state = states[state][name];\n        ref = states[state];\n        \n        name = lexeme.symbol;\n        me.pstate = state;\n        \n        // shift\n        if (name in ref) {\n            return 1;\n        \n        }\n        // reduce\n        else if (state in ends) {\n            return 2;\n        }\n        \n        me.params = 'failed reduce! inside :reduce';\n        return 0;\n        \n    },\n    \n    ':success': function (lexeme) {\n        var me = this;\n        \n        me.completed =\n            me.returns = true;\n\n        me.current = lexeme;\n        \n        return false;\n    },\n    \n    ':fail': function (error) {\n        var me = this;\n        \n        me.error = error;\n        me.completed = true;\n        \n        return false;\n    },\n    \n    isAcceptableToken: function (token) {\n        return !(token[0] in this.parser.map.exclude);\n    },\n    \n    update: function (value) {\n        var me = this,\n            current = me.current;\n        \n        if (!me.error && current) {\n            \n            current.value = value;\n            \n        }\n        \n        return this;\n    },\n    \n    reset: function () {\n        var parser = this.parser;\n        \n        this.nextTokenIndex = 0;\n        this.cursor = 0;\n        this.buffer = [];\n        \n        this.state = this.start;\n        this.pstate = parser.map.start;\n        this.params = null;\n        \n        if (!this.subject) {\n            delete this.ready;\n        }\n        \n        delete this.complete;\n        delete this.error;\n        \n        delete this.returns;\n        delete this.current;\n        \n    },\n    \n    set: function (subject) {\n        if (!string(subject)) {\n            throw new Error(\"Invalid String subject parameter.\");\n        }\n        \n        this.reset();\n        this.subject = subject;\n        this.ready = true;\n        \n\n    },\n    \n    next: function () {\n        var me = this,\n            actions = me.actions,\n            isNumber = number,\n            completed = me.completed,\n            returns = false;\n        var state, params, result, ref, current;\n\n        // reset current\n        if (!completed) {\n            delete me.current;\n        }\n        \n        for (; !completed;) {\n            \n            state = me.state;\n            params = me.params;\n            \n            // check if it action can be transitioned\n            if (!(state in me)) {\n                throw new Error(\"No handler found for state \" + state);\n            }\n            \n            // handle transition\n            result = me[state](params);\n            returns = me.returns;\n            delete me.returns;\n            current = me.current;\n            completed = me.completed;\n            \n            // break on error\n            if (me.error) {\n                break;\n            }\n            \n            // after transition, may error caught or successfully completed\n            if (!completed) {\n                \n                // accepts number result\n                if (!isNumber(result)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                    \n                // can transition to next state\n                ref = actions[state];\n                \n                if (!(result in ref)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                \n                me.state = ref[result];\n            }\n            \n            // return params\n            if (returns === true) {\n                return current;\n            }\n            \n            \n        }\n        \n        return me.error || !completed ? false : null;\n        \n    }\n};\n\nexport default BaseIterator;\n","'use strict';\n\nimport {\n            string,\n            method\n        } from \"libcore\";\n\nimport BaseIterator from \"./iterator/base.js\";\n        \nvar defaultIteratorName = \"base\",\n    ITERATORS = {};\n\nexport\n    function register(name, Class) {\n        var Base = BaseIterator;\n        \n        if (!string(name)) {\n            throw new Error(\"Invalid iterator name parameter.\");\n        }\n        \n        if (!method(Class) ||\n            (Class !== Base && !(Class.prototype instanceof Base))) {\n            throw new Error(\"Invalid iterator Class parameter.\");\n        }\n        \n        ITERATORS[':' + name] = Class;\n        \n        return true;\n    }\n\nexport\n    function get(name) {\n        var list = ITERATORS;\n        \n        if (string(name)) {\n            name = ':' + name;\n            if (name in list) {\n                return list[name];\n            }\n        }\n        \n        return null;\n    }\n\nexport {\n            defaultIteratorName as defaultIterator,\n            BaseIterator as Base\n        };\n\nregister(defaultIteratorName, BaseIterator);\n\n\n","'use strict';\n\nimport {\n            string,\n            object,\n            array\n\n        } from \"libcore\";\n\nimport Tokenizer from \"libcore-tokenizer\";\n\nimport StateMap from \"./state/map.js\";\n\nimport builder from \"./state/builder.js\";\n\nimport {\n            get as iteratorGet,\n            defaultIterator\n        } from \"./iterator.js\";\n\n\nfunction Parser(root, definition, exclude) {\n    \n    this.tokenizer = new Tokenizer();\n    this.map = new StateMap();\n    \n    if (arguments.length) {\n        this.define(root, definition, exclude);\n    }\n}\n\n\nParser.prototype = {\n    subject: '',\n    tokenizer: null,\n    map: null,\n    ready: false,\n    constructor: Parser,\n    \n    iterator: function (name) {\n        var get = iteratorGet;\n        var Iterator;\n        \n        if (arguments.length) {\n            Iterator = get(name);\n            if (!Iterator) {\n                throw new Error(\"Invalid iterator name parameter.\");\n            }\n        }\n        else {\n            Iterator = get(defaultIterator);\n        }\n        \n        return new Iterator(this);\n    },\n    \n    define: function (root, definition, exclude) {\n        var isArray = array;\n        var ready;\n        \n        if (!isArray(exclude)) {\n            exclude = [];\n        }\n        \n        if (!string(root)) {\n            throw new Error(\"Invalid root grammar rule parameter.\");\n        }\n        \n        if (!isArray(definition)) {\n            throw new Error(\"Invalid grammar rules definition parameter\");\n        }\n        \n        \n        this.ready = ready = builder(root,\n                                    this.map,\n                                    this.tokenizer,\n                                    definition,\n                                    exclude);\n        \n        return ready;\n\n    },\n    \n    fromJSON: function (json) {\n        var isObject = object;\n        var tokenMap;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\"Invalid JSON String json parameter.\");\n            }\n        }\n        \n        if (!isObject(json)) {\n            throw new Error(\"Invalid Object json parameter.\");\n        }\n        \n        tokenMap = json.tokens;\n        \n        if (!isObject(tokenMap)) {\n            throw new Error('Invalid \"tokens\" property of json parameter.');\n        }\n        \n        this.tokenizer.fromJSON(tokenMap);\n        this.map.importStates(json);\n        \n        return this;\n        \n    },\n    \n    toJSON: function () {\n        return JSON.stringify(this.toObject());\n    },\n    \n    toObject: function () {\n        var object;\n        \n        if (!this.ready) {\n            throw new Error(\"Grammar rules is not yet defined.\");\n        }\n        \n        object = this.map.toObject();\n        object.tokens = this.tokenizer.toObject();\n        \n        return object;\n    },\n    \n    parse: function (subject, reducer, iterator) {\n        var isString = string,\n            rpn = [],\n            rl = 0;\n        var lexeme, name, value;\n        \n        if (!isString(subject)) {\n            throw new Error(\"Invalid string subject parameter\");\n        }\n        \n        iterator = isString(iterator) ?\n                        this.iterator(iterator) :\n                        this.iterator();\n        \n        if (!iterator) {\n            throw new Error(\"Invalid Iterator parameter.\");\n        }\n        \n        if (!object(reducer)) {\n            reducer = {};\n        }\n        \n        iterator.set(subject);\n        \n        for (lexeme = iterator.next(); lexeme; lexeme = iterator.next()) {\n            rpn[rl++] = lexeme;\n            \n            name = lexeme.name;\n            if (name in reducer) {\n                value = reducer[name](name, lexeme.value, lexeme);\n                \n                if (typeof value !== \"undefined\") {\n                    lexeme.value = value;\n                }\n                else if (lexeme.params !== 0) {\n                    lexeme.value = null;\n                }\n                \n            }\n            \n        }\n        \n        return iterator.error ? false : rpn;\n        \n    }\n};\n\n\nexport default Parser;","'use strict';\n\nimport {\n            string,\n            object\n        } from \"libcore\";\n        \nimport Parser from \"./parser.js\";\n\nexport { Parser };\n\nexport {\n            Base as Iterator,\n            register as registerIterator\n        } from \"./iterator.js\";\n\nexport\n    function define(root, definitions, exclusions) {\n        return new Parser(root, definitions, exclusions);\n    }\n\nexport\n    function load(json) {\n        var parser;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\n                    \"Unable to load from invalid json JSON String parameter: \" +\n                    e.toString());\n            }\n        }\n        else if (!object(json)) {\n            throw new Error(\"Unable to load from invalid json Object parameter.\");\n        }\n        \n        parser = new Parser();\n        \n        try {\n            parser.fromJSON(json);\n        }\n        catch (e) {\n            throw new Error(e);\n        }\n        \n        return parser;\n    }\nexport\n    function isParser(parser) {\n        return parser instanceof Parser;\n    }\n\n\n\n\n// integrate to libcore\n//module.exports = libcore.lalr = {\n//    Parser: Parser,\n//    Iterator: iteratorManager.Base,\n//    isParser: isParser,\n//    define: define,\n//    load: load,\n//    registerIterator: iteratorManager.register\n//};"],"names":["StateMap","states","this","stateGen","symbolGen","reduceGen","root","lookup","symbol","start","anchors","ends","exclude","finalized","rawStates","reduceLookup","reducers","augmentedRoot","generateSymbol","endSymbol","endToken","empty","clone","obj","E","prototype","Pointer","lexeme","state","item","to","Item","id","map","list","generateState","base","watched","reduceList","recursion","references","length","define","grammar","anchor","production","rule","ruleId","params","queue","pendingRecursion","defineState","ruleIndex","rules","ruleGroup","setExcludes","getRecursionItem","watchItem","createRecursion","insertNextQueue","appendQueue","point","reduce","nextInQueue","registerToken","definition","name","reference","len","terminal","alias","tokenAlias","tokens","pendingTerminals","source","Error","lookupSymbol","indexOf","defineTerminal","c","l","setToken","isRegex","regex","errorMessage","array","defineRule","lexemes","token","created","suffix","from","current","lexemeId","lexIndex","ruleNames","ruleNameRe","RULE_NAME_RE","registerTerminal","isString","string","test","rgenId","join","build","stateMap","tokenizer","definitions","dc","dl","pl","original","groups","group","callback","isArray","registerRule","defineToken","grammarRoot","isTerminalName","reset","splice","slice","contains","defineStates","finalize","Lexeme","type","useType","BaseIterator","parser","object","register","Class","Base","method","ITERATORS","get","Parser","Tokenizer","arguments","exclusions","load","json","JSON","parse","e","toString","fromJSON","isParser","constructor","symbols","access","generateReduceId","all","lookupReducer","setAnchorState","setReduceState","importStates","isObject","toObject","has","exportStates","stringify","next","parent","pointer","contextPointer","after","last","getPointerItem","found","onSetPointer","context","stateObject","TYPE","nonterminal","compound","end","value","reduceCount","first","previous","types","subject","returns","ready","completed","error","actions",":start","0","1",":tokenize","2","3",":shift",":reduce",":fail",":success","me","nextTokenIndex","ref","literal","pstate","tokenize","isAcceptableToken","buffer","litem","bl","endIndex","values","update","cursor","complete","set","result","isNumber","number","iterator","Iterator","iteratorGet","builder","tokenMap","toJSON","reducer","rpn","rl"],"mappings":"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"}