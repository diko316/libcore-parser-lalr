{"version":3,"file":"libcore-parser-lalr.min.js","sources":["../src/state/map.js","../src/state/builder/rule.js","../src/state/define/list.js","../src/state/define/state.js","../src/state/define.js","../src/state/builder/registry.js","../src/state/builder.js","../src/lexeme.js","../src/iterator/base.js","../src/iterator.js","../src/parser.js","../src/all.js"],"sourcesContent":["'use strict';\n\n\nimport {\n            string,\n            object,\n            array,\n            contains\n            \n        } from \"libcore\";\n\nfunction StateMap(debug) {\n    var start = \"$\",\n        end = \"$end\",\n        tokenEnd = \"$\",\n        states = {};\n\n    this.stateGen =\n        this.symbolGen =\n        this.reduceGen = 0;\n\n    states[start] = {};\n    this.root = end;\n    this.lookup = {};\n    this.symbol = {};\n    this.start = start;\n    this.states = states;\n    this.ends = {};\n    this.exclude = {};\n    this.finalized = false;\n    this.rawStates = [];\n\n    this.reduceLookup = {};\n    this.reducers = {};\n    this.debugMode = debug === true;\n\n    this.augmentedRoot = this.generateSymbol(end);\n    this.endSymbol = this.generateSymbol(tokenEnd);\n    this.endToken = tokenEnd;\n\n}\n\n\nStateMap.prototype = {\n    stateGen: 0,\n    rawStates: null,\n    debugMode: false,\n    \n    constructor: StateMap,\n\n    createState: function (id) {\n        var states = this.states;\n\n        if (id in states) {\n            return states[id];\n        }\n        return (states[id] = {});\n    },\n    \n    createPointer: function (id, token, target) {\n        var state = this.createState(id);\n\n        state[token] = target;\n\n        return state;\n\n    },\n\n    generateSymbol: function (name) {\n\n        var lookup = this.lookup,\n            symbols = this.symbol,\n            access = ':' + name;\n        var id;\n        \n        if (access in lookup) {\n            return lookup[access];\n        }\n    \n        // create symbol\n        id = this.debugMode ?\n                '[' + name + ']' :\n                (++this.symbolGen).toString(36);\n\n        lookup[access] = id;\n        symbols[id] = name;\n    \n        return id;\n    \n    },\n\n    generateReduceId: function (name, params, ruleIndex) {\n        var lookup = this.reduceLookup,\n            all = this.reducers,\n            access = name + ':' + params + ':' + ruleIndex;\n        var id;\n\n        if (access in lookup) {\n            return lookup[access];\n        }\n\n        id = this.debugMode ?\n                '[' + name + ':' + params + '>' + ruleIndex + ']' :\n                (++this.reduceGen).toString(36);\n\n        lookup[access] = id;\n        all[id] = [name, params, ruleIndex];\n\n        return id;\n    },\n\n    lookupReducer: function (id) {\n        var all = this.reducers;\n        \n        if (id in all) {\n            return all[id];\n        }\n\n        return false;\n    },\n\n    lookupSymbol(name) {\n        var symbols = this.symbol;\n\n        if (name in symbols) {\n            return symbols[name];\n        }\n\n        return false;\n\n    },\n    \n    setReduceState: function (state, name, params, ruleIndex) {\n        var ends = this.ends,\n            id = this.generateReduceId(name, params, ruleIndex),\n            all = this.reducers;\n        var current;\n        \n        if (state in ends) {\n            current = all[ends[state]];\n            if (current[0] !== name || current[1] !== params) {\n                throw new Error(\"Reduce conflict found \" +\n                                this.lookupSymbol(current[0]) + ' ! <- ' +\n                                this.lookupSymbol(name));\n            }\n        }\n        else {\n            ends[state] = id;\n        }\n        \n    },\n    \n    reset: function () {\n        this.constructor(this.debugMode);\n    },\n\n    finalize: function() {\n        var list = this.rawStates;\n        var c, l;\n\n        if (!this.finalized && list) {\n            this.finalized = true;\n\n            for (c = -1, l = list.length; l--;) {\n                list[++c].finalize();\n            }\n\n            // remove raw states\n            list.length = 0;\n\n            // remove lookup\n            delete this.lookup;\n        }\n        \n        return this.finalized;\n    },\n    \n    setExcludes: function (exclude) {\n        var current = this.exclude;\n        var c, l;\n        \n        if (array(exclude)) {\n            for (c = -1, l = exclude.length; l--;) {\n                current[exclude[++c]] = true;\n            }\n        }\n    },\n    \n    importStates: function (definition) {\n        var isObject = object,\n            isString = string;\n        var start, states, ends, root, exclude, symbol, reducers,\n            list, c, l;\n        \n        if (!isObject(definition)) {\n            throw new Error(\"Invalid Object definition parameter.\");\n        }\n        \n        states = definition.states;\n        if (!isObject(states)) {\n            throw new Error(\n                        'Invalid \"states\" Object in definition parameter.');\n        }\n        \n        root = definition.root;\n        if (!isString(root)) {\n            throw new Error(\n                        'Invalid \"root\" grammar rule in definition parameter.');\n        }\n        \n        start = definition.start;\n        if (!isString(start) || !(start in states)) {\n            throw new Error(\n                        'Invalid \"start\" state in definition parameter.');\n        }\n        \n        ends = definition.ends;\n        if (!isObject(ends)) {\n            throw new Error('Invalid \"ends\" states in definition parameter.');\n        }\n\n        reducers = definition.reducers;\n        if (!isObject(reducers)) {\n            throw new Error('Invalid production \"reducers\" in definition.');\n        }\n\n        symbol = definition.symbol;\n        if (!isObject(symbol)) {\n            throw new Error('Invalid \"symbol\" map in definition parameter.');\n        }\n\n        list = definition.exclude;\n        if (!array(list)) {\n            throw new Error('Invalid \"exclude\" token in definition parameter.');\n        }\n\n        exclude = {};\n        for (c = -1, l = list.length; l--;) {\n            exclude[list[++c]] = true;\n        }\n        \n        this.root = root;\n        this.start = start;\n        this.states = states;\n        this.ends = ends;\n        this.reducers = reducers;\n        this.exclude = exclude;\n        this.symbol = symbol;\n        \n        return true;\n    },\n    \n    toObject: function () {\n        var has = contains,\n            exclude = this.exclude,\n            list = [],\n            len = 0;\n        var name;\n\n        // export exclude\n        for (name in exclude) {\n            if (has(exclude, name)) {\n                list[len++] = name;\n            }\n        }\n\n\n        return {\n                root: this.root,\n                start: this.start,\n                states: this.states,\n                reducers: this.reducers,\n                ends: this.ends,\n                exclude: list,\n                symbol: this.symbol\n            };\n    },\n    \n    exportStates: function (json) {\n        var current = this.toObject();\n            \n        if (json === true) {\n            try {\n                return JSON.stringify(current);\n            }\n            catch (e) {\n                return null;\n            }\n        }\n        \n        return current;\n    }\n    \n    \n};\n\n\nexport default StateMap;","'use strict';\n\nimport {\n            regex,\n            string,\n            array\n        } from \"libcore\";\n\nvar LEXEME_RE = /^([A-Z][a-zA-Z]+(\\_?[a-zA-Z0-9])*|\\$end|\\$)$/;\n\nexport\n    function isTerminal(name) {\n        return name === \"$\" || !LEXEME_RE.test(name);\n    }\n\nexport \n    function defineTerminals(registry, name, definitions) {\n        var isRegex = regex;\n        var c, l, terminal;\n\n        for (c = -1, l = definitions.length; l--;) {\n            terminal = definitions[++c];\n\n            if (!isRegex(terminal)) {\n                throw new Error(\"Invalid Terminal pattern: \" + terminal);\n            }\n\n            if (!registry.registerTerminal(terminal, name)) {\n                throw new Error(\"Invalid Terminal pattern: \" + terminal);\n            }\n\n        }\n\n    }\n\n\n\nexport \n    function defineRules(registry, name, definitions) {\n        var isString = string,\n            isRegex = regex,\n            isArray = array,\n            isTerm = isTerminal;\n\n        var c, l, rl, rule, lexeme, ruleMask, terminals, isTerminalToken;\n\n        for (c = -1, l = definitions.length; l--;) {\n            rule = definitions[++c];\n            if (isString(rule) || isRegex(rule)) {\n                rule = [rule];\n            }\n            else if (!isArray(rule)) {\n                throw new Error(\"Invalid Grammar rule declared in \" + name);\n            }\n\n            //console.log(\"define rules: \", name, \" definitions \", rule);\n\n            // create rule mask\n            rl = rule.length;\n            ruleMask = [];\n            terminals = {};\n\n            for (; rl--;) {\n                lexeme = rule[rl];\n\n                if (isRegex(lexeme)) {\n\n                    if (!registry.terminalExist(lexeme)) {\n                        registry.registerTerminal(lexeme);\n                    }\n\n                    lexeme = '/' + lexeme.source + '/';\n                    isTerminalToken = true;\n                }\n                else if (!isString(lexeme)) {\n                    throw new Error(\"Invalid Grammar rule declared in \" + name);\n                }\n                else {\n                    isTerminalToken = isTerm(lexeme);\n                }\n\n                \n                //console.log(\"hashed! \", ruleMask[rl]);\n                ruleMask[rl] = registry.map.generateSymbol(lexeme);//registry.hashLexeme(lexeme);\n\n                if (isTerminalToken) {\n                    terminals[rl] = true;\n                }\n                \n            }\n\n            // define states from ruleMask\n            registry.registerRule(name, ruleMask, terminals);\n\n        }\n\n\n\n    }","'use strict';\n\n\nfunction List(name) {\n    this.name = name;\n}\n\nList.prototype = {\n    constructor: List,\n    first: null,\n    last: null,\n\n    shift: function () {\n        var item = this.first;\n        var first;\n\n        if (item) {\n            this.first = first = item[0];\n            if (!first) {\n                this.last = first;\n            }\n            return item[1];\n        }\n        \n\n        return null;\n    },\n\n    push: function (item) {\n        item = [null, item];\n\n        if (this.last) {\n            this.last[0] = item;\n        }\n        else {\n            this.first = item;\n        }\n\n        this.last = item;\n\n        return this;\n    }\n};\n\nexport default List;","'use strict';\n\nimport List from \"./list.js\";\n\nfunction State(registry, id) {\n    var list = registry.vstates;\n\n    id = id || (++registry.vstateIdGen).toString(36);\n    \n    registry.vstateLookup[id] = \n        list[list.length] = this;\n    \n    this.id = id;\n    this.registry = registry;\n    this.tags = {};\n    this.tagNames = [];\n    this.pointer = new List();\n    this.rparent = null;\n    this.recursedAs = {};\n    \n}\n\nState.prototype = {\n    pointer: null,\n    registry: null,\n    constructor: State,\n\n    tag: function (id) {\n        var list = this.tags,\n            names = this.tagNames;\n\n        if (!(id in list)) {\n            list[id] = true;\n            names[names.length] = id;\n        }\n\n        return this;\n    },\n\n    hasTag: function (id) {\n        return id in this.tags;\n    },\n\n    setRecursed: function (production) {\n        var access = ':' + production,\n            list = this.recursedAs;\n\n        if (!(access in list)) {\n            list[access] = true;\n        }\n\n        return this;\n    },\n\n    isRecursed: function (production) {\n        var access = ':' + production,\n            list = this.recursedAs;\n\n        return access in list;\n    },\n\n    findRecursion: function (id) {\n        var me = this,\n            parent = me.rparent;\n\n        for (; parent; parent = parent.rparent) {\n            if (parent.hasTag(id)) {\n                return parent;\n            }\n        }\n        return null;\n    },\n\n    pointed: function (token) {\n        var pointer = this.pointer.first;\n        var item;\n\n        for (; pointer; pointer = pointer[0]) {\n            item = pointer[1];\n            if (item[1] === token) {\n                return item[0];\n            }\n        }\n        \n        return null;\n    },\n\n    pointTo: function (token, state) {\n        this.pointer.push([state, token]);\n        return state;\n    },\n\n    point: function (token, recurseState) {\n        var pointed = this.pointed(token);\n        var newState;\n\n        // create\n        if (!pointed) {\n            newState = new State(this.registry);\n            newState.rparent = recurseState;\n\n            return this.pointTo(token, newState);\n\n        }\n\n        return pointed;\n    }\n};\n\nexport default State;","'use strict';\n\nimport State from \"./define/state.js\";\n\nimport List from \"./define/list.js\";\n\n\nfunction define(registry) {\n\n    var map = registry.map,\n        StateClass = State,\n        STATE_END = 0,\n        STATE_START = 1,\n        STATE_RUN_RULES = 2,\n        STATE_START_RULE = 3,\n        STATE_DEFINE_LEXEME = 4,\n        STATE_DEFINE_ENDER = 5,\n        STATE_END_RULES = 6,\n        Queue = List,\n        defineState = STATE_START,\n        start = new StateClass(registry, map.start),\n        queue = new Queue('queue'),\n        pending = new Queue('pending'),\n        processed = {},\n        endStateList = [],\n        esl = 0,\n        iterations = 0;\n\n    var item, rules, rule, rindex, rlen, lexemes, tokens,\n        id, token, lindex, llen,\n        state, production, recursion, enqueue,\n        ruleState, tagged,\n        pointed, target,\n        pid, empties, redirectStates, emptyStatesByReducer, endState, reduceId,\n        redirected,\n        states, pointer, c, l;\n\n    //var limit = 1000;\n\n    queue.push([start, map.augmentedRoot]);\n    esl = 0;\n\n    for (; defineState;) {\n        iterations++;\n        // if (!--limit) {\n        //     break;\n        // }\n\n        switch (defineState) {\n        case STATE_START:\n            item = queue.shift();\n\n            production = item[1];\n            ruleState = item[0];\n\n            // go to next\n            if (ruleState.isRecursed(production)) {\n                defineState = STATE_END_RULES;\n                break;\n            }\n\n            ruleState.setRecursed(production);\n            rules = registry.getRules(production);\n            if (!rules) {\n                throw new Error(\"Production is not defined: \" +\n                                map.lookupSymbol(production));\n            }\n            lexemes = rules[1];\n            rules = rules[0];\n            rindex = -1;\n            rlen = rules.length;\n            defineState = STATE_RUN_RULES;\n            \n\n        /* falls through */\n        case STATE_RUN_RULES:\n            if (!(rlen--)) {\n                defineState = STATE_END_RULES;\n                break;\n            }\n\n            rule = rules[++rindex];\n            tokens = lexemes[rindex];\n            defineState = STATE_START_RULE;\n            \n\n        /* falls through */\n        case STATE_START_RULE:\n            lindex = -1;\n            llen = tokens.length;\n\n            id = rule[0];\n            token = tokens[0];\n            state = ruleState;\n\n            if (state.hasTag(id)) {\n                defineState = STATE_RUN_RULES;\n                break;\n            }\n            \n            target = state.findRecursion(id, token);\n            if (target) {\n                pointed = target.pointed(token);\n                if (pointed && !state.pointed(token)) {\n                    state.pointTo(token, pointed);\n                }\n            }\n\n            defineState = STATE_DEFINE_LEXEME;\n\n        /* falls through */\n        case STATE_DEFINE_LEXEME:\n\n            id = rule[++lindex];\n            tagged = state.hasTag(id);\n            \n\n            // dont redefine, go to next rule\n            if (!(llen--) || tagged) {\n                defineState = tagged ?\n                                STATE_RUN_RULES : STATE_DEFINE_ENDER;\n                break;\n            }\n\n            //console.log(\"define id! \", id);\n\n            token = tokens[lindex];\n\n            // recursion\n            recursion = registry.isRecursed(id);\n            pid = state.id + ':' + recursion;\n\n            // dont send to pending if already processed\n            if (recursion && !(pid in processed)) {\n                processed[pid] = true; \n                (state === ruleState ?\n                    queue : pending).push([state, recursion]);\n            }\n\n            state.tag(id);\n            state = state.pointed(token) || state.point(token, ruleState);\n\n            break;\n\n        /* falls through */\n        case STATE_DEFINE_ENDER:\n            id = rule[lindex];\n            state.tag(id);\n            registry.setEnd(state.id, production, lindex, id);\n            endStateList[esl++] = state;\n            defineState = STATE_RUN_RULES;\n            break;\n        \n        case STATE_END_RULES:\n            enqueue = queue.last;\n\n            if (!enqueue && pending.last) {\n                queue.push(enqueue = pending.shift());\n            }\n\n            defineState = enqueue ? STATE_START : STATE_END;\n            // if (!enqueue) {\n            //     console.log(\"ended! iterations: \", 1000 - limit);\n            // }\n        }\n        \n    }\n\n    if (map.debugMode) {\n        console.log(\"define iterations: \", iterations);\n        console.log(\"generated states: \", registry.vstates.length);\n    }\n    //console.log(\"iterations: \", 1000 - limit);\n\n    //console.log(registry);\n\n\n\n    // generate state map\n    states = registry.vstates;\n    empties = 0;\n    //var endstates = 0;\n    redirectStates = {};\n    emptyStatesByReducer = {};\n\n    // generate redirections to end states\n    for (; esl--;) {\n        state = endStateList[esl];\n\n        // no pointer! then this is a very good candidate\n        if (!state.pointer.first) {\n            id = state.id;\n            endState = registry.isEnd(id);\n            reduceId = map.generateReduceId(endState[0],\n                                            endState[1],\n                                            endState[2]);\n            // register as reduce state\n            if (!(reduceId in emptyStatesByReducer)) {\n                emptyStatesByReducer[reduceId] = id;\n            }\n            // create redirection\n            else {\n                redirectStates[id] = emptyStatesByReducer[reduceId];\n            }\n        }\n    }\n\n    for (c = - 1, l = states.length; l--;) {\n        state = states[++c];\n        id = state.id;\n        pointer = state.pointer.first;\n\n        if (pointer) {\n            map.createState(id);\n            for (; pointer; pointer = pointer[0]) {\n                item = pointer[1];\n                target = item[0].id;\n\n                // change target state id\n                if (target in redirectStates) {\n                    target = redirectStates[target];\n                }\n\n                map.createPointer(id, item[1], target);\n            }\n        }\n        \n        item = registry.isEnd(id);\n        if (item && !(id in redirectStates)) {\n            map.createState(id);\n            map.setReduceState(id, item[0], item[1], item[2]);\n        }\n\n        \n    }\n    \n\n    \n    // generate report\n    // var states = registry.vstates,\n    //     ends = registry.ends;\n    // var c, l, state, pointer, end;\n\n    // for (c = -1, l = states.length; l--;) {\n    //     state = states[++c];\n    //     pointer = state.pointer.first;\n    //     if (!pointer) {\n    //         console.log('no transitions in ', state.id);\n    //     }\n    //     for (;pointer; pointer = pointer[0]) {\n    //         item = pointer[1];\n    //         target = item[0];\n    //         end = target.id in ends ?\n    //                 ' end: ' + ends[target.id].join(',') : '';\n\n    //         console.log(state.id, ':', item[1], '->', target.id, end);\n    //     }\n    // }\n    // console.log(registry.vstates);\n    // console.log(queue, pending);\n    \n}\n\n\n\n\n\nexport default define;","'use strict';\n\nimport {\n            string,\n            contains\n        } from \"libcore\";\n\n\nfunction Registry(map, tokenizer) {\n    this.tokenizer = tokenizer;\n    this.map = map;\n\n    this.productions = {};\n    this.lexemes = {};\n\n    this.stateIndex = {};\n    this.vstateIdGen = 0;\n    this.vstateLookup = {};\n    this.vstates = [];\n    this.ends = {};\n\n\n    this.recursions = {};\n    \n    this.terminals = [];\n    this.terminalLookup = {};\n\n    this.symbolGen = 0;\n    this.symbol = {};\n    this.lookup = {};\n\n    this.stateTagIdGen = 0;\n    this.stateTagId = {};\n    this.stateTagIdLookup = {};\n\n    \n\n}\n\nRegistry.prototype = {\n    constructor: Registry,\n\n    startRule: null,\n    rules: null,\n\n    hashState: function (name) {\n        var lookup = this.stateTagIdLookup,\n            access = ':' + name;\n        var id;\n\n        if (access in lookup) {\n            return lookup[access];\n        }\n\n        id = this.map.debugMode ?\n                ':' + name :\n                (++this.stateTagIdGen).toString(36);\n\n        lookup[access] = id;\n        this.stateTagId[id] = name;\n\n        return id;\n\n    },\n\n    lookupState: function (id) {\n        var list = this.stateTagId;\n        \n        return id in list ? list[id] : null;\n    },\n\n    hashLexeme: function (name) {\n        \n        var lookup = this.lookup,\n            symbols = this.symbol,\n            access = ':' + name;\n        var id;\n        \n        if (access in lookup) {\n            return lookup[access];\n        }\n    \n        // create symbol\n        id = this.map.debugMode ?\n                '[' + name + ']' :\n                (++this.symbolGen).toString(36);\n    \n        lookup[access] = id;\n        symbols[id] = name;\n    \n        return id;\n    \n    },\n\n    lookupLexeme: function (id) {\n        var lookup = this.lookup;\n        return id in lookup ? lookup[id] : null;\n    },\n\n    terminalExist: function (terminal) {\n        var lookup = this.terminalLookup;\n\n        return string(terminal) ?\n                    contains(lookup, terminal) :\n                    '/' + terminal.source + '/' in lookup;\n    },\n\n    registerTerminal: function (terminal, name) {\n        var lookup = this.terminalLookup,\n            names = this.terminals,\n            access = this.map.generateSymbol('/' + terminal.source + '/');\n        var list;\n\n        if (!name) {\n            name = access;\n        }\n\n        // allow register\n        if (!(access in lookup)) {\n            \n            lookup[access] = name;\n\n            // register named\n            if (access === name) {\n                names[names.length] = name;\n\n            }\n            else if (!contains(lookup, name)) {\n                names[names.length] = name;\n                lookup[name] = [access];\n\n            }\n            else {\n                list = lookup[name];\n                list[list.length] = access;\n            }\n\n            this.tokenizer.define([name, terminal]);\n\n            return name;\n            \n        }\n\n        return false;\n\n\n    },\n\n    registerRule: function (name, mask, terminals) {\n        var states = this.stateIndex,\n            recursions = this.recursions,\n            productions = this.productions,\n            lexemes = this.lexemes,\n            rules = [],\n            rl = 0,\n            c = -1,\n            total = mask.length,\n            l = total + 1;\n        var items, id, lexeme, list, index;\n\n        if (!(name in productions)) {\n            productions[name] = [];\n            lexemes[name] = [];\n        }\n\n        list = productions[name];\n        index = list.length;\n        list[index] = rules;\n        lexemes[name][index] = mask;\n        \n        //console.log(\"------------------------------- Rules for: \" + name);\n\n        for (; l--;) {\n            lexeme = mask[++c];\n\n            items = mask.slice(0);\n            items.splice(c, 0, '.');\n            id = this.hashState(name + ' -> ' + items.join(' '));\n\n            if (id in states) {\n                throw new Error(\"Duplicate Grammar Rule found \" +\n                            this.lookupState(id) + \" in production: \" +\n                            this.map.lookupSymbol(name));\n            }\n\n            rules[rl++] = id;\n\n            states[id] = id;\n\n            // non-terminal\n            if (l && !(c in terminals)) {\n                //console.log(\"recusion? \", id, \" is \", lexeme);\n                recursions[id] = lexeme;\n            }\n\n        }\n\n    },\n\n    getRules: function (production) {\n        var list = this.productions;\n\n        return production in list ?\n                    [list[production], this.lexemes[production]] : null;\n    },\n\n    isRecursed: function (id) {\n        var recursions = this.recursions;\n        return id in recursions && recursions[id];\n    },\n\n    setEnd: function (id, production, params, ruleId) {\n        var ends = this.ends,\n            map = this.map,\n            state = this.vstateLookup[id];\n\n        if (!(id in ends)) {\n            ends[id] = [production, params, ruleId];\n        }\n        else if (ends[id][0] !== production) {\n            throw new Error(\"Reduce conflict! \" + state.id +\n                                \":\" + map.lookupSymbol(ends[id][0]) + ' <- ' +\n                                map.lookupSymbol(production));\n        }\n        \n    },\n\n    isEnd: function (id) {\n        var ends = this.ends;\n        return id in ends && ends[id];\n    }\n};\n\n\nexport default Registry;","'use strict';\n\nimport {\n            string,\n            regex,\n            array\n            \n        } from \"libcore\";\n        \n\n\nimport  {\n            isTerminal,\n            defineTerminals,\n            defineRules\n        } from \"./builder/rule.js\";\n\nimport define from \"./define.js\";\n\nimport Registry from \"./builder/registry.js\";\n\n\n        \n\n\nfunction build(root, map, tokenizer, definitions, exclude) {\n    var isString = string,\n        isArray = array,\n        isRegex = regex,\n        \n        isTerm = isTerminal,\n        defTerminal = defineTerminals,\n        defRule = defineRules,\n        name = null,\n        original = name,\n        \n        terminalDefinition = true;\n\n    var c, l, definition, registry, excludes;\n\n\n    map.reset();\n    \n    map.root = map.generateSymbol(\"$\" + root);\n\n    registry = new Registry(map, tokenizer);\n\n    // augment root\n    definitions.splice(definitions.length,\n                       0,\n                       map.lookupSymbol(map.augmentedRoot),\n                        [[ root, map.lookupSymbol(map.endSymbol)]]);\n\n    for (c = -1, l = definitions.length; l--;) {\n        \n        definition = definitions[++c];\n        \n        if (isString(definition)) {\n\n            terminalDefinition = isTerm(definition);\n            name = map.generateSymbol(definition);\n            original = definition;\n\n        }\n        else if (name && isArray(definition)) {\n\n            (terminalDefinition ?\n                defTerminal :\n                defRule)(registry, name, definition);\n\n        }\n        else {\n            throw new Error(\"Invalid item in definitions parameter.\");\n        }\n    }\n\n    define(registry);\n\n    // register excludes\n    if (isArray(exclude)) {\n        excludes = [];\n\n        //console.log(\"excludes! \", exclude);\n        for (c = -1, l = exclude.length; l--;) {\n            definition = exclude[++c];\n            if (isRegex(definition)) {\n                definition = registry.registerTerminal(definition);\n            }\n            else if (isString(definition)) {\n                definition = map.generateSymbol(definition);\n            }\n            else {\n                throw new Error(\"Invalid [exclude] pattern parameter.\");\n            }\n            \n            excludes[c] = definition;\n\n        }\n\n        map.setExcludes(excludes);\n    }\n\n    return true;\n}\n\n\nexport default build;\n\n","'use strict';\n\nimport { contains } from \"libcore\";\n\nvar TYPE = {\n        terminal: 1,\n        nonterminal: 2,\n        compound: 3,\n        end: 4\n    };\n    \n    \n\nfunction Lexeme(type) {\n    this.terminal = false;\n    this.useType(type);\n}\n\n\nLexeme.prototype = {\n    constructor: Lexeme,\n    name: null,\n    rule: null,\n    value: null,\n    reduceCount: 0,\n    from: 0,\n    to: 0,\n    \n    parent: null,\n    first: null,\n    last: null,\n    next: null,\n    previous: null,\n    terminal: false,\n    \n    useType: function (type) {\n        var types = TYPE;\n        this.type = type = contains(types, type) ?\n                                types[type] : types.token;\n        if (type === TYPE.terminal) {\n            this.terminal = true;\n        }\n    }\n};\n\nexport {\n        TYPE as type,\n        Lexeme\n    };\n\nexport default Lexeme;","'use strict';\n\nimport {\n            string,\n            number,\n            object\n        } from \"libcore\";\n        \nimport Lexeme from \"../lexeme.js\";\n\nvar INVALID_STATE_HANDLER = \"Invalid result from state handler\";\n\nfunction BaseIterator(parser) {\n    if (!object(parser)) {\n        throw new Error(\"Invalid parser parameter.\");\n    }\n    \n    this.parser = parser;\n    this.reset();\n    \n    this.start = ':start';\n}\n\n\nBaseIterator.prototype = {\n    constructor: BaseIterator,\n    subject: '',\n    returns: false,\n    current: null,\n    ready: false,\n    completed: false,\n    error: null,\n    \n    actions: {\n        ':start': {\n            0: ':fail',\n            1: ':tokenize'\n            \n        },\n        \n        ':tokenize': {\n            0: ':fail',\n            1: ':tokenize',\n            2: ':shift',\n            3: ':reduce'\n        },\n        \n        ':shift': {\n            0: ':fail',\n            1: ':tokenize'\n        },\n        \n        ':reduce': {\n            0: ':fail',\n            1: ':shift',\n            2: ':reduce',\n            3: ':success'\n        },\n        ':fail': {},\n        ':success': {}\n    },\n    \n    ':start': function () {\n        var me = this;\n        \n        me.params = me.nextTokenIndex;\n        \n        return 1;\n    },\n    \n    ':tokenize': function (from) {\n        var me = this,\n            parser = me.parser,\n            map = parser.map,\n            ends = map.ends,\n            states = map.states,\n            state = me.pstate,\n            token = parser.tokenizer.tokenize(from,\n                                              me.subject),\n            endToken = map.endToken;\n            \n        var name, to, ref, lexeme, literal;\n\n        \n        \n        if (token) {\n            name = token[0];\n            to = token[2];\n            \n            // tokenize again\n            if (!this.isAcceptableToken(token)) {\n                me.params = to;\n                return 1;\n            }\n\n            \n            \n            lexeme = new Lexeme('terminal');\n\n            // end token is not symbolized!\n            literal = name;\n            if (name === endToken) {\n                name = map.endSymbol;\n            }\n            else {\n                literal = map.symbol[name];\n            }\n\n            \n            \n            lexeme.name = literal;\n            lexeme.symbol = name;\n            lexeme.value = token[1];\n            lexeme.from = from;\n            lexeme.to = to;\n            \n            me.nextTokenIndex = to;\n            me.params = lexeme;\n            \n            // found shift state\n            ref = states[state];\n\n            //console.log(\"token accepted! \", token, name, ' shift? ', ref);\n\n            if (name in ref) {\n                return 2;\n            }\n\n        }\n        \n        // can reduce remaining buffer\n        if (me.buffer.length && state in ends) {\n            return 3;\n        }\n        \n        // failed\n        me.params = 'Invalid token';\n        return 0;\n        \n    },\n    \n    ':shift': function (lexeme) {\n        var me = this,\n            buffer = me.buffer,\n            map = me.parser.map,\n            states = map.states,\n            state = me.pstate,\n            name = lexeme.symbol;\n        \n        buffer[buffer.length] = [state, lexeme];\n        \n        me.pstate = states[state][name];\n        me.current = lexeme;\n        me.params = null;\n        \n        // do not return \"$\" token\n        me.returns = name !== map.endSymbol;\n        me.params = me.nextTokenIndex;\n\n        //console.log(\"shift from ! \", state, lexeme.value, \" to \", me.pstate);\n        \n        return 1;\n\n    },\n    \n    ':reduce': function (lexeme) {\n        var me = this,\n            map = me.parser.map,\n            buffer = me.buffer,\n            bl = buffer.length,\n            ends = map.ends,\n            states = map.states,\n            lookup = map.symbol,\n            state = me.pstate,\n            reduce = map.lookupReducer(ends[state]),\n            name = reduce[0],\n            params = reduce[1],\n            l = params,\n            endIndex = l - 1,\n            created = new Lexeme('nonterminal'),\n            values = [];\n            \n        var litem, item, from, to, ref, last;\n        \n        created.name = lookup[name];\n        created.symbol = name;\n        created.rule = lookup[reduce[2]];\n        last = null;\n        \n        //console.log(\"reduce count? \", params, \" from \", reduce);\n        \n        for (; l--;) {\n            item = buffer[--bl];\n            state = item[0];\n            litem = item[1];\n            \n            // create range\n            from = litem.from;\n            if (l === endIndex) {\n                to = litem.to;\n            }\n            \n            // create connection\n            litem.parent = created;\n             \n            if (last) {\n                last.previous = litem;\n                litem.next = last;\n            }\n            else {\n                created.last = litem;\n            }\n            created.first = last = litem;\n            values[l] = litem.value;\n        }\n        \n        created.value = values;\n        created.from = from;\n        created.to = to;\n        \n        buffer.length = bl;\n        \n        me.current = created;\n        \n        created.reduceCount = params;\n        \n        // only if it ended\n        if (name === map.augmentedRoot) {\n            \n            // end\n            if (bl === 0) {\n                litem = created.first;\n                \n                created.useType('end');\n                created.last = litem;\n                created.value = [litem.value];\n                created.rule = lookup[map.root];\n                created.reduceCount = 1;\n                \n                me.params = created;\n                \n                return 3;\n            }\n            else {\n                me.params = 'Failed last reduce';\n                return 0;\n            }\n            \n        }\n        \n        buffer[bl++] = [state, created];\n        me.returns = true;\n        \n        // iterate\n        state = states[state][name];\n        ref = states[state];\n        \n        name = lexeme.symbol;\n        me.pstate = state;\n       \n        // shift\n        //console.log('shift? ', name, 'lexeme', lexeme, ' in ', ref);\n        if (name in ref) {\n            return 1;\n        \n        }\n        // reduce\n        else if (state in ends) {\n            return 2;\n        }\n        \n        me.params = 'failed reduce! inside :reduce';\n        return 0;\n        \n    },\n    \n    ':success': function (lexeme) {\n        var me = this;\n        \n        me.completed =\n            me.returns = true;\n\n        me.current = lexeme;\n        \n        return false;\n    },\n    \n    ':fail': function (error) {\n        var me = this;\n        \n        me.error = error;\n        me.completed = true;\n        \n        return false;\n    },\n    \n    isAcceptableToken: function (token) {\n        return !(token[0] in this.parser.map.exclude);\n    },\n    \n    update: function (value) {\n        var me = this,\n            current = me.current;\n        \n        if (!me.error && current) {\n            \n            current.value = value;\n            \n        }\n        \n        return this;\n    },\n    \n    reset: function () {\n        var parser = this.parser;\n        \n        this.nextTokenIndex = 0;\n        this.cursor = 0;\n        this.buffer = [];\n        \n        this.state = this.start;\n        this.pstate = parser.map.start;\n        this.params = null;\n        \n        if (!this.subject) {\n            delete this.ready;\n        }\n        \n        delete this.complete;\n        delete this.error;\n        \n        delete this.returns;\n        delete this.current;\n        \n    },\n    \n    set: function (subject) {\n        if (!string(subject)) {\n            throw new Error(\"Invalid String subject parameter.\");\n        }\n        \n        this.reset();\n        this.subject = subject;\n        this.ready = true;\n        \n\n    },\n    \n    next: function () {\n        var me = this,\n            actions = me.actions,\n            isNumber = number,\n            completed = me.completed,\n            returns = false;\n        var state, params, result, ref, current;\n\n        if (!me.ready) {\n            throw new Error(\"Iterator is not yet ready, nothing to Parse.\");\n        }\n\n        // reset current\n        if (!completed) {\n            delete me.current;\n        }\n        \n        for (; !completed;) {\n            \n            state = me.state;\n            params = me.params;\n            \n            // check if it action can be transitioned\n            if (!(state in me)) {\n                throw new Error(\"No handler found for state \" + state);\n            }\n            \n            // handle transition\n            result = me[state](params);\n            returns = me.returns;\n            delete me.returns;\n            current = me.current;\n            completed = me.completed;\n            \n            // break on error\n            if (me.error) {\n                break;\n            }\n            \n            // after transition, may error caught or successfully completed\n            if (!completed) {\n                \n                // accepts number result\n                if (!isNumber(result)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                    \n                // can transition to next state\n                ref = actions[state];\n                \n                if (!(result in ref)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                \n                me.state = ref[result];\n            }\n            \n            // return params\n            if (returns === true) {\n                return current;\n            }\n            \n            \n        }\n        \n        return me.error || !completed ? false : null;\n        \n    }\n};\n\nexport default BaseIterator;\n","'use strict';\n\nimport {\n            string,\n            method\n        } from \"libcore\";\n\nimport BaseIterator from \"./iterator/base.js\";\n        \nvar defaultIteratorName = \"base\",\n    ITERATORS = {};\n\nexport\n    function register(name, Class) {\n        var Base = BaseIterator;\n        \n        if (!string(name)) {\n            throw new Error(\"Invalid iterator name parameter.\");\n        }\n        \n        if (!method(Class) ||\n            (Class !== Base && !(Class.prototype instanceof Base))) {\n            throw new Error(\"Invalid iterator Class parameter.\");\n        }\n        \n        ITERATORS[':' + name] = Class;\n        \n        return true;\n    }\n\nexport\n    function get(name) {\n        var list = ITERATORS;\n        \n        if (string(name)) {\n            name = ':' + name;\n            if (name in list) {\n                return list[name];\n            }\n        }\n        \n        return null;\n    }\n\nexport {\n            defaultIteratorName as defaultIterator,\n            BaseIterator as Base\n        };\n\nregister(defaultIteratorName, BaseIterator);\n\n\n","'use strict';\n\nimport {\n            string,\n            object,\n            array\n\n        } from \"libcore\";\n\nimport Tokenizer from \"libcore-tokenizer\";\n\nimport StateMap from \"./state/map.js\";\n\nimport builder from \"./state/builder.js\";\n\nimport {\n            get as iteratorGet,\n            defaultIterator\n        } from \"./iterator.js\";\n\nvar debugMode = false;\n\nfunction Parser(root, definition, exclude) {\n    \n    this.tokenizer = new Tokenizer();\n    this.map = new StateMap(debugMode);\n    \n    if (arguments.length) {\n        this.define(root, definition, exclude);\n    }\n}\n\n\nParser.prototype = {\n    subject: '',\n    tokenizer: null,\n    map: null,\n    ready: false,\n    constructor: Parser,\n    \n    iterator: function (name) {\n        var get = iteratorGet;\n        var Iterator;\n        \n        if (arguments.length) {\n            Iterator = get(name);\n            if (!Iterator) {\n                throw new Error(\"Invalid iterator name parameter.\");\n            }\n        }\n        else {\n            Iterator = get(defaultIterator);\n        }\n        \n        return new Iterator(this);\n    },\n    \n    define: function (root, definition, exclude) {\n        var isArray = array;\n        var ready;\n        \n        if (!isArray(exclude)) {\n            exclude = [];\n        }\n        \n        if (!string(root)) {\n            throw new Error(\"Invalid root grammar rule parameter.\");\n        }\n        \n        if (!isArray(definition)) {\n            throw new Error(\"Invalid grammar rules definition parameter\");\n        }\n        \n        \n        this.ready = ready = builder(root,\n                                    this.map,\n                                    this.tokenizer,\n                                    definition,\n                                    exclude);\n        \n        return ready;\n\n    },\n    \n    fromJSON: function (json) {\n        var isObject = object;\n        var tokenMap;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\"Invalid JSON String json parameter.\");\n            }\n        }\n        \n        if (!isObject(json)) {\n            throw new Error(\"Invalid Object json parameter.\");\n        }\n        \n        tokenMap = json.tokens;\n        \n        if (!isObject(tokenMap)) {\n            throw new Error('Invalid \"tokens\" property of json parameter.');\n        }\n        \n        this.tokenizer.fromJSON(tokenMap);\n        this.map.importStates(json);\n        \n        return this;\n        \n    },\n    \n    toJSON: function () {\n        return JSON.stringify(this.toObject());\n    },\n    \n    toObject: function () {\n        var object;\n        \n        if (!this.ready) {\n            throw new Error(\"Grammar rules is not yet defined.\");\n        }\n        \n        object = this.map.toObject();\n        object.tokens = this.tokenizer.toObject();\n        \n        return object;\n    },\n    \n    parse: function (subject, reducer, iterator) {\n        var isString = string,\n            rpn = [],\n            rl = 0;\n        var lexeme, name, value;\n        \n        if (!isString(subject)) {\n            throw new Error(\"Invalid string subject parameter\");\n        }\n        \n        iterator = isString(iterator) ?\n                        this.iterator(iterator) :\n                        this.iterator();\n        \n        if (!iterator) {\n            throw new Error(\"Invalid Iterator parameter.\");\n        }\n        \n        if (!object(reducer)) {\n            reducer = {};\n        }\n        \n        iterator.set(subject);\n        \n        for (lexeme = iterator.next(); lexeme; lexeme = iterator.next()) {\n            rpn[rl++] = lexeme;\n            \n            name = lexeme.name;\n            if (name in reducer) {\n                value = reducer[name](name, lexeme.value, lexeme);\n                \n                if (typeof value !== \"undefined\") {\n                    lexeme.value = value;\n                }\n                else if (lexeme.params !== 0) {\n                    lexeme.value = null;\n                }\n                \n            }\n            \n        }\n        \n        return iterator.error ? false : rpn;\n        \n    }\n};\n\n\nexport default Parser;\n\nexport\n    function debug(isDebugMode) {\n        debugMode = isDebugMode !== false;\n    }\n","'use strict';\n\nimport {\n            string,\n            object\n        } from \"libcore\";\n        \nimport Parser,\n        { debug } from \"./parser.js\";\n\nexport {\n            debug,\n            Parser\n        };\n\nexport {\n            Base as Iterator,\n            register as registerIterator\n        } from \"./iterator.js\";\n\nexport\n    function define(root, definitions, exclusions) {\n        return new Parser(root, definitions, exclusions);\n    }\n\nexport\n    function load(json) {\n        var parser;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\n                    \"Unable to load from invalid json JSON String parameter: \" +\n                    e.toString());\n            }\n        }\n        else if (!object(json)) {\n            throw new Error(\"Unable to load from invalid json Object parameter.\");\n        }\n        \n        parser = new Parser();\n        \n        try {\n            parser.fromJSON(json);\n        }\n        catch (e) {\n            throw new Error(e);\n        }\n        \n        return parser;\n    }\nexport\n    function isParser(parser) {\n        return parser instanceof Parser;\n    }\n\n\n\n\n// integrate to libcore\n//module.exports = libcore.lalr = {\n//    Parser: Parser,\n//    Iterator: iteratorManager.Base,\n//    isParser: isParser,\n//    define: define,\n//    load: load,\n//    registerIterator: iteratorManager.register\n//};"],"names":["StateMap","debug","states","this","stateGen","symbolGen","reduceGen","root","lookup","symbol","start","ends","exclude","finalized","rawStates","reduceLookup","reducers","debugMode","augmentedRoot","generateSymbol","endSymbol","endToken","isTerminal","name","LEXEME_RE","test","defineTerminals","registry","definitions","c","l","terminal","isRegex","regex","length","Error","registerTerminal","defineRules","rl","rule","lexeme","ruleMask","terminals","isTerminalToken","isString","string","isArray","array","isTerm","terminalExist","source","map","registerRule","List","State","id","list","vstates","vstateIdGen","toString","vstateLookup","tags","tagNames","pointer","rparent","recursedAs","define","item","rules","rindex","rlen","lexemes","tokens","token","lindex","llen","state","production","recursion","enqueue","ruleState","tagged","pointed","target","pid","redirectStates","emptyStatesByReducer","endState","reduceId","Queue","defineState","queue","pending","processed","endStateList","esl","iterations","push","shift","isRecursed","setRecursed","getRules","lookupSymbol","hasTag","findRecursion","pointTo","tag","point","setEnd","last","console","log","first","isEnd","generateReduceId","createState","createPointer","setReduceState","Registry","tokenizer","productions","stateIndex","recursions","terminalLookup","stateTagIdGen","stateTagId","stateTagIdLookup","build","definition","excludes","defTerminal","defRule","terminalDefinition","reset","splice","setExcludes","Lexeme","type","useType","BaseIterator","parser","object","register","Class","Base","method","prototype","ITERATORS","get","Parser","Tokenizer","arguments","isDebugMode","exclusions","load","json","JSON","parse","e","fromJSON","isParser","constructor","symbols","access","params","ruleIndex","all","lookupReducer","current","finalize","importStates","isObject","toObject","has","contains","len","exportStates","stringify","names","parent","recurseState","newState","startRule","hashState","lookupState","hashLexeme","lookupLexeme","mask","items","index","slice","join","ruleId","TYPE","nonterminal","compound","end","value","reduceCount","from","to","next","previous","types","subject","returns","ready","completed","error","actions",":start","0","1",":tokenize","2","3",":shift",":reduce",":fail",":success","me","nextTokenIndex","ref","literal","pstate","tokenize","isAcceptableToken","buffer","litem","bl","reduce","endIndex","created","values","update","cursor","complete","set","result","isNumber","number","iterator","Iterator","iteratorGet","builder","tokenMap","toJSON","reducer","rpn"],"mappings":"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"}