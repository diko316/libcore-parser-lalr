{"version":3,"file":"libcore-parser-lalr.min.js","sources":["../src/state/map.js","../src/helper.js","../src/state/object.js","../src/state/define.js","../src/state/builder.js","../src/lexeme.js","../src/iterator/base.js","../src/iterator.js","../src/parser.js","../src/all.js"],"sourcesContent":["'use strict';\n\n\nimport {\n            string,\n            object,\n            array\n            \n        } from \"libcore\";\n\nfunction StateMap() {\n    this.reset();\n}\n\n\nStateMap.prototype = {\n    stateGen: 0,\n    \n    constructor: StateMap,\n    \n    generateState: function () {\n        var id = 's' + (++this.stateGen);\n        this.states[id] = {};\n        return id;\n    },\n    \n    setAnchorState: function (state) {\n        var anchors = this.anchors;\n        \n        if (!(state in anchors)) {\n            this.anchors[state] = true;\n        }\n    },\n    \n    setReduceState: function (state, name, params, ruleIndex) {\n        var ends = this.ends;\n        var current;\n        \n        if (state in ends) {\n            current = ends[state];\n            if (current[0] !== name || current[1] !== params) {\n                throw new Error(\"Reduce conflict found \" +\n                                current[0] + ' ! <- ' + name);\n            }\n        }\n        else {\n            ends[state] = [name, params, ruleIndex];\n        }\n        \n    },\n    \n    reset: function () {\n        var start = '$start',\n            states = {};\n        \n        states[start] = {};\n        this.root = '$end';\n        this.start = start;\n        this.states = states;\n        this.anchors = {};\n        this.ends = {};\n        this.exclude = {};\n    },\n    \n    setExcludes: function (exclude) {\n        var current = this.exclude;\n        var c, l;\n        \n        if (array(exclude)) {\n            for (c = -1, l = exclude.length; l--;) {\n                current[exclude[++c]] = true;\n            }\n        }\n    },\n    \n    importStates: function (definition) {\n        var isObject = object,\n            isString = string;\n        var start, states, anchors, ends, root, exclude;\n        \n        if (!isObject(definition)) {\n            throw new Error(\"Invalid Object definition parameter.\");\n        }\n        \n        states = definition.states;\n        if (!isObject(states)) {\n            throw new Error(\n                        'Invalid \"states\" Object in definition parameter.');\n        }\n        \n        root = definition.root;\n        if (!isString(root)) {\n            throw new Error(\n                        'Invalid \"root\" grammar rule in definition parameter.');\n        }\n        \n        start = definition.start;\n        if (!isString(start) || !(start in states)) {\n            throw new Error(\n                        'Invalid \"start\" state in definition parameter.');\n        }\n        \n        anchors = definition.anchors;\n        if (!isObject(anchors)) {\n            throw new Error('Invalid \"anchors\" states in definition parameter.');\n        }\n        \n        ends = definition.ends;\n        if (!isObject(anchors)) {\n            throw new Error('Invalid \"ends\" states in definition parameter.');\n        }\n\n        exclude = definition.exclude;\n        if (!isObject(exclude)) {\n            throw new Error('Invalid \"exclude\" token in definition parameter.');\n        }\n        \n        this.root = root;\n        this.start = start;\n        this.states = states;\n        this.anchors = anchors;\n        this.ends = ends;\n        this.exclude = exclude;\n        \n        return true;\n    },\n    \n    toObject: function () {\n        return {\n                root: this.root,\n                start: this.start,\n                states: this.states,\n                anchors: this.anchors,\n                ends: this.ends,\n                exclude: this.exclude\n            };\n    },\n    \n    exportStates: function (json) {\n        var current = this.toObject();\n            \n        if (json === true) {\n            try {\n                return JSON.stringify(current);\n            }\n            catch (e) {\n                return null;\n            }\n        }\n        \n        return current;\n    }\n    \n    \n};\n\n\nexport default StateMap;","'use strict';\n\nfunction empty() {\n}\n\nexport\n    function clone(obj) {\n        var E = empty;\n        E.prototype = obj;\n        return new E();\n    }\n\n","'use strict';\n\nimport { clone } from \"../helper.js\";\n\nfunction StateObject(map, id) {\n    this.id = id;\n    this.map = map;\n    this.pointer = {};\n    this.lexemes = [];\n}\n\nStateObject.prototype = {\n    constructor: StateObject,\n    id: null,\n    pointer: null,\n    parent: null,\n    rid: null,\n    lexemes: null,\n    \n    clone: function (rid) {\n        var dupe = clone(this);\n        if (rid) {\n            dupe.rid = rid;\n        }\n        dupe.parent = this;\n\n        return dupe;\n    },\n    \n    point: function (lexeme) {\n        var pointer = this.pointer,\n            lexemes = this.lexemes,\n            map = this.map;\n        var vstate, state;\n        \n        if (!(lexeme in pointer)) {\n            state = this.map.generateState();\n            vstate = this.clone();\n            vstate.id = state;\n            vstate.pointer = {};\n            vstate.lexemes = [];\n            \n            lexemes[lexemes.length] = lexeme;\n            \n            pointer[lexeme] = vstate;\n            //console.log(this.id, ':', lexeme, '-> ', state);\n            map.states[this.id][lexeme] = state;\n        }\n        \n        return pointer[lexeme];\n        \n    },\n    \n    reduce: function (rule, params, ruleIndex) {\n        this.map.setReduceState(this.id, rule, params, ruleIndex);\n    }\n};\n\nexport default StateObject;","'use strict';\n\nimport StateObject from \"./object.js\";\n\nfunction define(grammar, map, exclude) {\n    \n    var SO = StateObject,\n        ruleIndex = grammar.rules,\n        ruleGroup = grammar.ruleGroup,\n        vstate = new SO(map, map.start),\n        rootName = \"$end\",\n        pending = [[vstate, rootName]],\n        l = 1;\n    var item, production, rule, lexeme, anchorState, ruleId, params,\n        recurse, ident, next;\n        \n    map.reset();\n    \n    map.root = grammar.root;\n    \n    if (exclude) {\n        map.setExcludes(exclude);\n    }\n\n    //var limit = 1000;\n    \n    for (; l--;) {\n\n        // if (!--limit) {\n        //     //console.log(\"limit reached!!!! \", l);\n        //     break;\n        // }\n\n        item = pending.splice(0, 1)[0];\n        anchorState = item[0];\n        production = item[1];\n        \n        // iterate rules\n        rule = ruleIndex[production];\n\n\n        for (; rule; rule = next) {\n            ruleId = rule[0];\n            next = rule[2];\n            \n            // reset\n            if (ruleId === false) {\n                params = 0;\n                vstate = anchorState;\n                \n            }\n            // run rule\n            else {\n                lexeme = rule[1];\n                params++;\n                \n                // for non-terminal\n                if (lexeme in ruleIndex) {\n\n                    ident = production + ':' + ruleId;\n\n                    \n\n                    //console.log(\"ident \", ident, \"lexeme \", lexeme, \" = \", ruleIndex[lexeme]);\n                    \n                    // ident = vstate.rid;\n                    // ident = ident ?\n                    //             ident + '-' + ruleId : ruleId;\n\n                    // // recurse\n                    if (!(ident in vstate)) {\n                        \n                        recurse = vstate.clone();\n                        recurse[ident] = recurse;\n                        pending[l++] = [recurse, lexeme];\n                        \n                    }\n                    \n                }\n                \n                // only if not skipped\n                vstate = vstate.point(lexeme);\n                \n                // set reduce state\n                if (!next || next[0] === false) {\n                    vstate.reduce(production, params, ruleGroup[ruleId]);\n                }\n                \n            }\n            \n        }\n\n        \n    }\n    \n    return true;\n}\n\n\nexport default define;","'use strict';\n\nimport {\n            string,\n            regex,\n            array,\n            contains\n            \n        } from \"libcore\";\n        \nimport defineStates from \"./define.js\";\n        \nvar RULE_NAME_RE = /^([A-Z][a-zA-Z]+(\\_?[a-zA-Z0-9])*|\\$end|\\$)$/;\n\nfunction define(name, rule, grammar, tokenizer) {\n    var rules = grammar.rules,\n        ruleIndex = grammar.ruleIndex,\n        terminal = grammar.terminal,\n        lexIndex = grammar.lexIndex,\n        ruleNames = grammar.ruleNames,\n        ruleNameRe = RULE_NAME_RE,\n        isString = string,\n        isRegex = regex;\n    var l, item, lexemes, token, tokenId, created,\n        prefix, suffix, from, to, current, lexemeId;\n    \n    if (isString(rule) || isRegex(rule)) {\n        rule = [rule];\n    }\n    \n    if (!array(rule)) {\n        throw new Error(\"Invalid grammar rule found in \" + name);\n    }\n    \n    from = to = null;\n    lexemes = [];\n    \n    for (l = rule.length; l--;) {\n        item = rule[l];\n        \n        if (isRegex(item)) {\n            token = item.source;\n            tokenId = '/' + item.source + '/';\n            \n            // register token\n            if (!(tokenId in terminal)) {\n                tokenizer.define([ tokenId, item ]);\n                terminal[tokenId] = tokenId;\n            }\n            \n            item = tokenId;\n        }\n        else if (!isString(item)) {\n            throw new Error(\"Invalid token in grammar rule \" + item);\n        }\n        else if (!ruleNameRe.test(item)) {\n            throw new Error(\"Invalid grammar rule name format: \" + item);\n        }\n        \n        lexemes[l] = item;\n        lexemeId = 'r' + (++grammar.rgenId);\n        lexIndex[lexemeId] = item;\n        created = [lexemeId, item, from];\n        \n        if (!from) {\n            to = created;\n        }\n        from = created;\n\n    }\n    \n    suffix = ' -> ' + lexemes.join(',');\n    prefix = name + ':';\n    tokenId = name + suffix;\n    \n    if (tokenId in ruleIndex) {\n        throw new Error(\"Grammar rule is already defined \" + name + suffix);\n    }\n    else {\n        ruleIndex[tokenId] = true;\n    }\n    \n    if (!(name in rules)) {\n        rules[name] = null;\n        ruleNames[ruleNames.length] = name;\n    }\n    \n    // append\n    from = [false, null, from];\n    current = rules[name];\n    \n    if (current) {\n        to[2] = current;\n    }\n    \n    rules[name] = from;\n    \n    return [from[2][0], to[0]];\n}\n\n\nfunction build(root, stateMap, tokenizer, definitions, exclude) {\n    var isString = string,\n        isArray = array,\n        isRegex = regex,\n        defineRule = define,\n        ruleNameRe = RULE_NAME_RE,\n        ruleNames = [];\n    var c, l, dc, dl, name, definition,\n        rules, grammar, groups, group, index, terminal;\n        \n    name = null;\n    rules = {};\n    grammar = {\n        root: '$' + root,\n        rgenId: 0,\n        ruleNames: ruleNames = [],\n        rules: rules,\n        terminal: terminal = {},\n        lexIndex: index = {},\n        ruleIndex: {},\n        ruleGroup: groups = {}\n    };\n    \n    // augment root\n    definitions.splice(definitions.length,\n                       0,\n                       \"$end\", [\n                            [ root, \"$\" ]\n                        ]);\n\n    for (c = -1, l = definitions.length; l--;) {\n        \n        definition = definitions[++c];\n        \n        if (isString(definition)) {\n            \n            if (!ruleNameRe.test(definition)) {\n                throw new Error(\"Invalid grammar rule name \" + definition);\n            }\n            name = definition;\n        \n        }\n        else if (isArray(definition)) {\n            \n            // do not accept grammar rule if it doesn't have name\n            if (!name) {\n                throw new Error(\"Invalid grammar rules parameter.\");\n            }\n            \n            dc = -1;\n            dl = definition.length;\n            \n            for (; dl--;) {\n                group = defineRule(name,\n                                   definition[++dc],\n                                   grammar,\n                                   tokenizer);\n                // register group\n                groups[group[1]] = name + (dc + 1);\n            }\n\n        }\n        else {\n            throw new Error(\"Invalid item in definitions parameter.\");\n        }\n        \n    }\n    \n    // add excludes\n    if (exclude) {\n        exclude = exclude.slice(0);\n        \n        for (l = exclude.length; l--;) {\n            definition = exclude[l];\n            \n            if (!isRegex(definition)) {\n                throw new Error(\"Invalid exclude token parameter.\");\n            }\n            \n            name = '/' + definition.source + '/';\n            if (!(name in terminal)) {\n                tokenizer.define([ name, definition ]);\n                terminal[name] = name;\n                exclude[l] = name;\n            }\n            else {\n                exclude.splice(l, 1);\n            }\n            \n        }\n        \n    }\n    \n    if (!contains(rules, root)) {\n        throw new Error(\"Invalid root grammar rule parameter.\");\n    }\n    \n    return defineStates(grammar, stateMap, exclude);\n\n}\n\nexport default build;\n\n","'use strict';\n\nimport { contains } from \"libcore\";\n\nvar TYPE = {\n        terminal: 1,\n        nonterminal: 2,\n        compound: 3\n    };\n    \n    \n\nfunction Lexeme(type) {\n    this.useType(type);\n}\n\n\nLexeme.prototype = {\n    constructor: Lexeme,\n    name: null,\n    rule: null,\n    value: null,\n    reduceCount: 0,\n    from: 0,\n    to: 0,\n    \n    parent: null,\n    first: null,\n    last: null,\n    next: null,\n    previous: null,\n    \n    useType: function (type) {\n        var types = TYPE;\n        this.type = contains(types, type) ?\n                        types[type] : types.token;\n    }\n};\n\nexport {\n        TYPE as type,\n        Lexeme\n    };\n\nexport default Lexeme;","'use strict';\n\nimport {\n            string,\n            number,\n            object\n        } from \"libcore\";\n        \nimport Lexeme from \"../lexeme.js\";\n\nvar INVALID_STATE_HANDLER = \"Invalid result from state handler\";\n\nfunction BaseIterator(parser) {\n    if (!object(parser)) {\n        throw new Error(\"Invalid parser parameter.\");\n    }\n    \n    this.parser = parser;\n    this.reset();\n    \n    this.start = ':start';\n}\n\n\nBaseIterator.prototype = {\n    constructor: BaseIterator,\n    subject: '',\n    returns: false,\n    current: null,\n    ready: false,\n    completed: false,\n    error: null,\n    \n    actions: {\n        ':start': {\n            0: ':fail',\n            1: ':tokenize'\n            \n        },\n        \n        ':tokenize': {\n            0: ':fail',\n            1: ':tokenize',\n            2: ':shift',\n            3: ':reduce'\n        },\n        \n        ':shift': {\n            0: ':fail',\n            1: ':tokenize'\n        },\n        \n        ':reduce': {\n            0: ':fail',\n            1: ':shift',\n            2: ':reduce',\n            3: ':success'\n        },\n        ':fail': {},\n        ':success': {}\n    },\n    \n    ':start': function () {\n        var me = this;\n        \n        me.params = me.nextTokenIndex;\n        \n        return 1;\n    },\n    \n    ':tokenize': function (from) {\n        var me = this,\n            parser = me.parser,\n            map = parser.map,\n            ends = map.ends,\n            states = map.states,\n            state = me.pstate,\n            token = parser.tokenizer.tokenize(from,\n                                              me.subject);\n            \n        var name, to, ref, lexeme;\n        \n        \n        if (token) {\n            name = token[0];\n            to = token[2];\n            \n            // tokenize again\n            if (!this.isAcceptableToken(token)) {\n                me.params = to;\n                return 1;\n            }\n            \n            lexeme = new Lexeme('terminal');\n            lexeme.name = name;\n            lexeme.value = token[1];\n            lexeme.from = from;\n            lexeme.to = to;\n            \n            me.nextTokenIndex = to;\n            me.params = lexeme;\n            \n            // found shift state\n            ref = states[state];\n            if (name in ref) {\n                return 2;\n            }\n\n        }\n        \n        // can reduce remaining buffer\n        if (me.buffer.length && state in ends) {\n            return 3;\n        }\n        \n        // failed\n        me.params = 'Invalid token';\n        return 0;\n        \n    },\n    \n    ':shift': function (lexeme) {\n        var me = this,\n            buffer = me.buffer,\n            states = me.parser.map.states,\n            state = me.pstate,\n            name = lexeme.name;\n        \n        buffer[buffer.length] = [state, lexeme];\n        \n        me.pstate = states[state][name];\n        me.current = lexeme;\n        me.params = null;\n        \n        // do not return \"$\" token\n        me.returns = name !== \"$\";\n        me.params = me.nextTokenIndex;\n        return 1;\n\n    },\n    \n    ':reduce': function (lexeme) {\n        var me = this,\n            map = me.parser.map,\n            buffer = me.buffer,\n            bl = buffer.length,\n            ends = map.ends,\n            states = map.states,\n            state = me.pstate,\n            reduce = ends[state],\n            name = reduce[0],\n            params = reduce[1],\n            l = params,\n            endIndex = l - 1,\n            created = new Lexeme('nonterminal'),\n            values = [];\n            \n        var litem, item, from, to, ref, last;\n        \n        created.name = name;\n        created.rule = reduce[2];\n        last = null;\n        \n        for (; l--;) {\n            item = buffer[--bl];\n            state = item[0];\n            litem = item[1];\n            \n            // create range\n            from = litem.from;\n            if (l === endIndex) {\n                to = litem.to;\n            }\n            \n            // create connection\n            litem.parent = created;\n             \n            if (last) {\n                last.previous = litem;\n                litem.next = last;\n            }\n            else {\n                created.last = litem;\n            }\n            created.first = last = litem;\n            values[l] = litem.value;\n        }\n        \n        created.value = values;\n        created.from = from;\n        created.to = to;\n        \n        buffer.length = bl;\n        \n        me.current = created;\n        \n        created.reduceCount = params;\n        \n        // only if it ended\n        if (name === '$end') {\n            \n            // end\n            if (bl === 0) {\n                litem = created.first;\n                \n                created.useType('end');\n                created.last = litem;\n                created.value = [litem.value];\n                created.rule = map.root;\n                created.reduceCount = 1;\n                \n                me.params = created;\n                \n                return 3;\n            }\n            else {\n                me.params = 'Failed last reduce';\n                return 0;\n            }\n            \n        }\n        \n        buffer[bl++] = [state, created];\n        me.returns = true;\n        \n        // iterate\n        state = states[state][name];\n        ref = states[state];\n        \n        name = lexeme.name;\n        me.pstate = state;\n        \n        // shift\n        if (name in ref) {\n            return 1;\n        \n        }\n        // reduce\n        else if (state in ends) {\n            return 2;\n        }\n        \n        me.params = 'failed reduce! inside :reduce';\n        return 0;\n        \n    },\n    \n    ':success': function (lexeme) {\n        var me = this;\n        \n        me.completed =\n            me.returns = true;\n\n        me.current = lexeme;\n        \n        return false;\n    },\n    \n    ':fail': function (error) {\n        var me = this;\n        \n        me.error = error;\n        me.completed = true;\n        \n        return false;\n    },\n    \n    isAcceptableToken: function (token) {\n        return !(token[0] in this.parser.map.exclude);\n    },\n    \n    update: function (value) {\n        var me = this,\n            current = me.current;\n        \n        if (!me.error && current) {\n            \n            current.value = value;\n            \n        }\n        \n        return this;\n    },\n    \n    reset: function () {\n        var parser = this.parser;\n        \n        this.nextTokenIndex = 0;\n        this.cursor = 0;\n        this.buffer = [];\n        \n        this.state = this.start;\n        this.pstate = parser.map.start;\n        this.params = null;\n        \n        if (!this.subject) {\n            delete this.ready;\n        }\n        \n        delete this.complete;\n        delete this.error;\n        \n        delete this.returns;\n        delete this.current;\n        \n    },\n    \n    set: function (subject) {\n        if (!string(subject)) {\n            throw new Error(\"Invalid String subject parameter.\");\n        }\n        \n        this.reset();\n        this.subject = subject;\n        this.ready = true;\n        \n\n    },\n    \n    next: function () {\n        var me = this,\n            actions = me.actions,\n            isNumber = number,\n            completed = me.completed,\n            returns = false;\n        var state, params, result, ref, current;\n\n        // reset current\n        if (!completed) {\n            delete me.current;\n        }\n        \n        for (; !completed;) {\n            \n            state = me.state;\n            params = me.params;\n            \n            // check if it action can be transitioned\n            if (!(state in me)) {\n                throw new Error(\"No handler found for state \" + state);\n            }\n            \n            // handle transition\n            result = me[state](params);\n            returns = me.returns;\n            delete me.returns;\n            current = me.current;\n            completed = me.completed;\n            \n            // break on error\n            if (me.error) {\n                break;\n            }\n            \n            // after transition, may error caught or successfully completed\n            if (!completed) {\n                \n                // accepts number result\n                if (!isNumber(result)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                    \n                // can transition to next state\n                ref = actions[state];\n                \n                if (!(result in ref)) {\n                    throw new Error(INVALID_STATE_HANDLER + state);\n                }\n                \n                me.state = ref[result];\n            }\n            \n            // return params\n            if (returns === true) {\n                return current;\n            }\n            \n            \n        }\n        \n        return me.error || !completed ? false : null;\n        \n    }\n};\n\nexport default BaseIterator;\n","'use strict';\n\nimport {\n            string,\n            method\n        } from \"libcore\";\n\nimport BaseIterator from \"./iterator/base.js\";\n        \nvar defaultIteratorName = \"base\",\n    ITERATORS = {};\n\nexport\n    function register(name, Class) {\n        var Base = BaseIterator;\n        \n        if (!string(name)) {\n            throw new Error(\"Invalid iterator name parameter.\");\n        }\n        \n        if (!method(Class) ||\n            (Class !== Base && !(Class.prototype instanceof Base))) {\n            throw new Error(\"Invalid iterator Class parameter.\");\n        }\n        \n        ITERATORS[':' + name] = Class;\n        \n        return true;\n    }\n\nexport\n    function get(name) {\n        var list = ITERATORS;\n        \n        if (string(name)) {\n            name = ':' + name;\n            if (name in list) {\n                return list[name];\n            }\n        }\n        \n        return null;\n    }\n\nexport {\n            defaultIteratorName as defaultIterator,\n            BaseIterator as Base\n        };\n\nregister(defaultIteratorName, BaseIterator);\n\n\n","'use strict';\n\nimport {\n            string,\n            object,\n            array\n\n        } from \"libcore\";\n\nimport Tokenizer from \"libcore-tokenizer\";\n\nimport StateMap from \"./state/map.js\";\n\nimport builder from \"./state/builder.js\";\n\nimport {\n            get as iteratorGet,\n            defaultIterator\n        } from \"./iterator.js\";\n\n\nfunction Parser(root, definition, exclude) {\n    \n    this.tokenizer = new Tokenizer();\n    this.map = new StateMap();\n    \n    if (arguments.length) {\n        this.define(root, definition, exclude);\n    }\n}\n\n\nParser.prototype = {\n    subject: '',\n    tokenizer: null,\n    map: null,\n    ready: false,\n    constructor: Parser,\n    \n    iterator: function (name) {\n        var get = iteratorGet;\n        var Iterator;\n        \n        if (arguments.length) {\n            Iterator = get(name);\n            if (!Iterator) {\n                throw new Error(\"Invalid iterator name parameter.\");\n            }\n        }\n        else {\n            Iterator = get(defaultIterator);\n        }\n        \n        return new Iterator(this);\n    },\n    \n    define: function (root, definition, exclude) {\n        var isArray = array;\n        var ready;\n        \n        if (!isArray(exclude)) {\n            exclude = [];\n        }\n        \n        if (!string(root)) {\n            throw new Error(\"Invalid root grammar rule parameter.\");\n        }\n        \n        if (!isArray(definition)) {\n            throw new Error(\"Invalid grammar rules definition parameter\");\n        }\n        \n        \n        this.ready = ready = builder(root,\n                                    this.map,\n                                    this.tokenizer,\n                                    definition,\n                                    exclude);\n        \n        return ready;\n\n    },\n    \n    fromJSON: function (json) {\n        var isObject = object;\n        var tokenMap;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\"Invalid JSON String json parameter.\");\n            }\n        }\n        \n        if (!isObject(json)) {\n            throw new Error(\"Invalid Object json parameter.\");\n        }\n        \n        tokenMap = json.tokens;\n        \n        if (!isObject(tokenMap)) {\n            throw new Error('Invalid \"tokens\" property of json parameter.');\n        }\n        \n        this.tokenizer.fromJSON(tokenMap);\n        this.map.importStates(json);\n        \n        return this;\n        \n    },\n    \n    toJSON: function () {\n        return JSON.stringify(this.toObject());\n    },\n    \n    toObject: function () {\n        var object;\n        \n        if (!this.ready) {\n            throw new Error(\"Grammar rules is not yet defined.\");\n        }\n        \n        object = this.map.toObject();\n        object.tokens = this.tokenizer.toObject();\n        \n        return object;\n    },\n    \n    parse: function (subject, reducer, iterator) {\n        var isString = string,\n            rpn = [],\n            rl = 0;\n        var lexeme, name, value;\n        \n        if (!isString(subject)) {\n            throw new Error(\"Invalid string subject parameter\");\n        }\n        \n        iterator = isString(iterator) ?\n                        this.iterator(iterator) :\n                        this.iterator();\n        \n        if (!iterator) {\n            throw new Error(\"Invalid Iterator parameter.\");\n        }\n        \n        if (!object(reducer)) {\n            reducer = {};\n        }\n        \n        iterator.set(subject);\n        \n        for (lexeme = iterator.next(); lexeme; lexeme = iterator.next()) {\n            rpn[rl++] = lexeme;\n            \n            name = lexeme.name;\n            if (name in reducer) {\n                value = reducer[name](name, lexeme.value, lexeme);\n                \n                if (typeof value !== \"undefined\") {\n                    lexeme.value = value;\n                }\n                else if (lexeme.params !== 0) {\n                    lexeme.value = null;\n                }\n                \n            }\n            \n        }\n        \n        return iterator.error ? false : rpn;\n        \n    }\n};\n\n\nexport default Parser;","'use strict';\n\nimport {\n            string,\n            object\n        } from \"libcore\";\n        \nimport Parser from \"./parser.js\";\n\nexport { Parser };\n\nexport {\n            Base as Iterator,\n            register as registerIterator\n        } from \"./iterator.js\";\n\nexport\n    function define(root, definitions, exclusions) {\n        return new Parser(root, definitions, exclusions);\n    }\n\nexport\n    function load(json) {\n        var parser;\n        \n        if (string(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                throw new Error(\n                    \"Unable to load from invalid json JSON String parameter: \" +\n                    e.toString());\n            }\n        }\n        else if (!object(json)) {\n            throw new Error(\"Unable to load from invalid json Object parameter.\");\n        }\n        \n        parser = new Parser();\n        \n        try {\n            parser.fromJSON(json);\n        }\n        catch (e) {\n            throw new Error(e);\n        }\n        \n        return parser;\n    }\nexport\n    function isParser(parser) {\n        return parser instanceof Parser;\n    }\n\n\n\n\n// integrate to libcore\n//module.exports = libcore.lalr = {\n//    Parser: Parser,\n//    Iterator: iteratorManager.Base,\n//    isParser: isParser,\n//    define: define,\n//    load: load,\n//    registerIterator: iteratorManager.register\n//};"],"names":["StateMap","this","reset","empty","clone","obj","E","prototype","StateObject","map","id","pointer","lexemes","define","grammar","exclude","item","production","rule","lexeme","anchorState","ruleId","params","recurse","ident","next","SO","ruleIndex","rules","ruleGroup","vstate","start","pending","l","root","setExcludes","splice","point","reduce","name","tokenizer","tokenId","created","suffix","from","to","current","lexemeId","terminal","lexIndex","ruleNames","ruleNameRe","RULE_NAME_RE","isString","string","isRegex","regex","array","Error","length","source","test","rgenId","join","build","stateMap","definitions","c","dc","dl","definition","groups","isArray","defineRule","slice","contains","defineStates","Lexeme","type","useType","BaseIterator","parser","object","register","Class","Base","method","ITERATORS","get","list","Parser","Tokenizer","arguments","exclusions","load","json","JSON","parse","e","toString","fromJSON","isParser","stateGen","constructor","generateState","states","setAnchorState","state","anchors","setReduceState","ends","importStates","isObject","toObject","exportStates","stringify","parent","rid","dupe","TYPE","nonterminal","compound","value","reduceCount","first","last","previous","types","token","subject","returns","ready","completed","error","actions",":start","0","1",":tokenize","2","3",":shift",":reduce",":fail",":success","me","nextTokenIndex","ref","pstate","tokenize","isAcceptableToken","buffer","litem","bl","endIndex","values","update","cursor","complete","set","result","isNumber","number","iterator","Iterator","iteratorGet","builder","tokenMap","tokens","toJSON","reducer","rpn","rl"],"mappings":"4TAUA,SAASA,IACLC,KAAKC,QCTT,SAASC,KAGT,SACaC,EAAMC,GACX,IAAIC,EAAIH,EAER,OADAG,EAAEC,UAAYF,EACP,IAAIC,ECLnB,SAASE,EAAYC,EAAKC,GACtBT,KAAKS,GAAKA,EACVT,KAAKQ,IAAMA,EACXR,KAAKU,WACLV,KAAKW,WCJT,SAASC,EAAOC,EAASL,EAAKM,GAE1B,IAOIC,EAAMC,EAAYC,EAAMC,EAAQC,EAAaC,EAAQC,EACrDC,EAASC,EAAOC,EARhBC,EAAKlB,EACLmB,EAAYb,EAAQc,MACpBC,EAAYf,EAAQe,UACpBC,EAAS,IAAIJ,EAAGjB,EAAKA,EAAIsB,OAEzBC,IAAYF,EADD,SAEXG,EAAI,EAcR,IAVAxB,EAAIP,QAEJO,EAAIyB,KAAOpB,EAAQoB,KAEfnB,GACAN,EAAI0B,YAAYpB,GAKbkB,KAeH,IAPAb,GADAJ,EAAOgB,EAAQI,OAAO,EAAG,GAAG,IACT,GAInBlB,EAAOS,EAHPV,EAAaD,EAAK,IAMXE,EAAMA,EAAOO,EAChBJ,EAASH,EAAK,GACdO,EAAOP,EAAK,IAGG,IAAXG,GACAC,EAAS,EACTQ,EAASV,IAMTE,KADAH,EAASD,EAAK,MAIAS,KAEVH,EAAQP,EAAa,IAAMI,KAWZS,KAEXP,EAAUO,EAAO1B,SACToB,GAASD,EACjBS,EAAQC,MAAQV,EAASJ,KAOjCW,EAASA,EAAOO,MAAMlB,GAGjBM,IAAoB,IAAZA,EAAK,IACdK,EAAOQ,OAAOrB,EAAYK,EAAQO,EAAUR,KAU5D,OAAO,ECjFX,SAASR,EAAO0B,EAAMrB,EAAMJ,EAAS0B,GACjC,IAQIP,EAAGjB,EAAMJ,EAAgB6B,EAASC,EAC1BC,EAAQC,EAAMC,EAAIC,EAASC,EATnCnB,EAAQd,EAAQc,MAChBD,EAAYb,EAAQa,UACpBqB,EAAWlC,EAAQkC,SACnBC,EAAWnC,EAAQmC,SACnBC,EAAYpC,EAAQoC,UACpBC,EAAaC,EACbC,EAAWC,SACXC,EAAUC,QAQd,IAJIH,EAASnC,IAASqC,EAAQrC,MAC1BA,GAAQA,KAGPuC,QAAMvC,GACP,MAAM,IAAIwC,MAAM,iCAAmCnB,GAMvD,IAHAK,EAAOC,EAAK,KACZjC,KAEKqB,EAAIf,EAAKyC,OAAQ1B,KAAM,CAGxB,GAFAjB,EAAOE,EAAKe,GAERsB,EAAQvC,GACAA,EAAK4C,QACbnB,EAAU,IAAMzB,EAAK4C,OAAS,OAGbZ,IACbR,EAAU3B,QAAS4B,EAASzB,IAC5BgC,EAASP,GAAWA,GAGxBzB,EAAOyB,MAEN,CAAA,IAAKY,EAASrC,GACf,MAAM,IAAI0C,MAAM,iCAAmC1C,GAElD,IAAKmC,EAAWU,KAAK7C,GACtB,MAAM,IAAI0C,MAAM,qCAAuC1C,GAG3DJ,EAAQqB,GAAKjB,EAEbiC,EADAF,EAAW,OAASjC,EAAQgD,QACP9C,EACrB0B,GAAWK,EAAU/B,EAAM4B,GAEtBA,IACDC,EAAKH,GAETE,EAAOF,EAQX,GAJAC,EAAS,OAAS/B,EAAQmD,KAAK,KACtBxB,EAAO,KAChBE,EAAUF,EAAOI,KAEFhB,EACX,MAAM,IAAI+B,MAAM,mCAAqCnB,EAAOI,GAqBhE,OAlBIhB,EAAUc,IAAW,EAGnBF,KAAQX,IACVA,EAAMW,GAAQ,KACdW,EAAUA,EAAUS,QAAUpB,GAIlCK,IAAQ,EAAO,KAAMA,IACrBE,EAAUlB,EAAMW,MAGZM,EAAG,GAAKC,GAGZlB,EAAMW,GAAQK,GAENA,EAAK,GAAG,GAAIC,EAAG,IAI3B,SAASmB,EAAM9B,EAAM+B,EAAUzB,EAAW0B,EAAanD,GACnD,IAMIoD,EAAGlC,EAAGmC,EAAIC,EAAI9B,EAAM+B,EACpB1C,EAAOd,EAASyD,EAAsBvB,EAPtCK,EAAWC,SACXkB,EAAUf,QACVF,EAAUC,QACViB,EAAa5D,EACbsC,EAAaC,EAyBjB,IApBAb,EAAO,KAEPzB,GACIoB,KAAM,IAAMA,EACZ4B,OAAQ,EACRZ,aACAtB,MALJA,KAMIoB,SAAUA,KACVC,YACAtB,aACAE,UAAW0C,MAIfL,EAAY9B,OAAO8B,EAAYP,OACZ,EACA,SACOzB,EAAM,OAG3BiC,GAAK,EAAGlC,EAAIiC,EAAYP,OAAQ1B,KAIjC,GAFAqC,EAAaJ,IAAcC,GAEvBd,EAASiB,GAAa,CAEtB,IAAKnB,EAAWU,KAAKS,GACjB,MAAM,IAAIZ,MAAM,6BAA+BY,GAEnD/B,EAAO+B,MAGN,CAAA,IAAIE,EAAQF,GAqBb,MAAM,IAAIZ,MAAM,0CAlBhB,IAAKnB,EACD,MAAM,IAAImB,MAAM,oCAMpB,IAHAU,GAAM,EACNC,EAAKC,EAAWX,OAETU,KAMHE,EALQE,EAAWlC,EACA+B,IAAaF,GACbtD,EACA0B,GAEN,IAAMD,GAAQ6B,EAAK,GAW5C,GAAIrD,EAGA,IAAKkB,GAFLlB,EAAUA,EAAQ2D,MAAM,IAEPf,OAAQ1B,KAAM,CAG3B,GAFAqC,EAAavD,EAAQkB,IAEhBsB,EAAQe,GACT,MAAM,IAAIZ,MAAM,qCAGpBnB,EAAO,IAAM+B,EAAWV,OAAS,OACnBZ,EAMVjC,EAAQqB,OAAOH,EAAG,IALlBO,EAAU3B,QAAS0B,EAAM+B,IACzBtB,EAAST,GAAQA,EACjBxB,EAAQkB,GAAKM,GAUzB,IAAKoC,WAAS/C,EAAOM,GACjB,MAAM,IAAIwB,MAAM,wCAGpB,OAAOkB,EAAa9D,EAASmD,EAAUlD,GC1L3C,SAAS8D,EAAOC,GACZ7E,KAAK8E,QAAQD,GCDjB,SAASE,EAAaC,GAClB,IAAKC,SAAOD,GACR,MAAM,IAAIvB,MAAM,6BAGpBzD,KAAKgF,OAASA,EACdhF,KAAKC,QAELD,KAAK8B,MAAQ,SCRjB,SACaoD,EAAS5C,EAAM6C,GACpB,IAAIC,EAAOL,EAEX,IAAK1B,SAAOf,GACR,MAAM,IAAImB,MAAM,oCAGpB,IAAK4B,SAAOF,IACPA,IAAUC,KAAUD,EAAM7E,qBAAqB8E,GAChD,MAAM,IAAI3B,MAAM,qCAKpB,OAFA6B,EAAU,IAAMhD,GAAQ6C,GAEjB,EAGf,SACaI,EAAIjD,GACT,IAAIkD,EAAOF,EAEX,OAAIjC,SAAOf,KACPA,EAAO,IAAMA,KACDkD,EACDA,EAAKlD,GAIb,KCpBf,SAASmD,EAAOxD,EAAMoC,EAAYvD,GAE9Bd,KAAKuC,UAAY,IAAImD,EACrB1F,KAAKQ,IAAM,IAAIT,EAEX4F,UAAUjC,QACV1D,KAAKY,OAAOqB,EAAMoC,EAAYvD,GCVlC,SAASF,EAAOqB,EAAMgC,EAAa2B,GAC/B,OAAO,IAAIH,EAAOxD,EAAMgC,EAAa2B,GAG7C,SACaC,EAAKC,GACV,IAAId,EAEJ,GAAI3B,SAAOyC,GACP,IACIA,EAAOC,KAAKC,MAAMF,GAEtB,MAAOG,GACH,MAAM,IAAIxC,MACN,2DACAwC,EAAEC,iBAGT,IAAKjB,SAAOa,GACb,MAAM,IAAIrC,MAAM,sDAGpBuB,EAAS,IAAIS,EAEb,IACIT,EAAOmB,SAASL,GAEpB,MAAOG,GACH,MAAM,IAAIxC,MAAMwC,GAGpB,OAAOjB,EAEf,SACaoB,EAASpB,GACd,OAAOA,aAAkBS,+CTrCjC1F,EAASO,WACL+F,SAAU,EAEVC,YAAavG,EAEbwG,cAAe,WACX,IAAI9F,EAAK,OAAST,KAAKqG,SAEvB,OADArG,KAAKwG,OAAO/F,MACLA,GAGXgG,eAAgB,SAAUC,GAGhBA,KAFQ1G,KAAK2G,UAGf3G,KAAK2G,QAAQD,IAAS,IAI9BE,eAAgB,SAAUF,EAAOpE,EAAMjB,EAAQK,GAC3C,IACImB,EADAgE,EAAO7G,KAAK6G,KAGhB,GAAIH,KAASG,GAET,IADAhE,EAAUgE,EAAKH,IACH,KAAOpE,GAAQO,EAAQ,KAAOxB,EACtC,MAAM,IAAIoC,MAAM,yBACAZ,EAAQ,GAAK,SAAWP,QAI5CuE,EAAKH,IAAUpE,EAAMjB,EAAQK,IAKrCzB,MAAO,WACH,IACIuG,KAEJA,EAAY,UACZxG,KAAKiC,KAAO,OACZjC,KAAK8B,MALO,SAMZ9B,KAAKwG,OAASA,EACdxG,KAAK2G,WACL3G,KAAK6G,QACL7G,KAAKc,YAGToB,YAAa,SAAUpB,GACnB,IACIoD,EAAGlC,EADHa,EAAU7C,KAAKc,QAGnB,GAAI0C,QAAM1C,GACN,IAAKoD,GAAK,EAAGlC,EAAIlB,EAAQ4C,OAAQ1B,KAC7Ba,EAAQ/B,IAAUoD,KAAM,GAKpC4C,aAAc,SAAUzC,GACpB,IAEIvC,EAAO0E,EAAQG,EAASE,EAAM5E,EAAMnB,EAFpCiG,EAAW9B,SACX7B,EAAWC,SAGf,IAAK0D,EAAS1C,GACV,MAAM,IAAIZ,MAAM,wCAIpB,GADA+C,EAASnC,EAAWmC,QACfO,EAASP,GACV,MAAM,IAAI/C,MACE,oDAIhB,GADAxB,EAAOoC,EAAWpC,MACbmB,EAASnB,GACV,MAAM,IAAIwB,MACE,wDAIhB,GADA3B,EAAQuC,EAAWvC,QACdsB,EAAStB,IAAYA,KAAS0E,GAC/B,MAAM,IAAI/C,MACE,kDAIhB,GADAkD,EAAUtC,EAAWsC,SAChBI,EAASJ,GACV,MAAM,IAAIlD,MAAM,qDAIpB,GADAoD,EAAOxC,EAAWwC,MACbE,EAASJ,GACV,MAAM,IAAIlD,MAAM,kDAIpB,GADA3C,EAAUuD,EAAWvD,SAChBiG,EAASjG,GACV,MAAM,IAAI2C,MAAM,oDAUpB,OAPAzD,KAAKiC,KAAOA,EACZjC,KAAK8B,MAAQA,EACb9B,KAAKwG,OAASA,EACdxG,KAAK2G,QAAUA,EACf3G,KAAK6G,KAAOA,EACZ7G,KAAKc,QAAUA,GAER,GAGXkG,SAAU,WACN,OACQ/E,KAAMjC,KAAKiC,KACXH,MAAO9B,KAAK8B,MACZ0E,OAAQxG,KAAKwG,OACbG,QAAS3G,KAAK2G,QACdE,KAAM7G,KAAK6G,KACX/F,QAASd,KAAKc,UAI1BmG,aAAc,SAAUnB,GACpB,IAAIjD,EAAU7C,KAAKgH,WAEnB,IAAa,IAATlB,EACA,IACI,OAAOC,KAAKmB,UAAUrE,GAE1B,MAAOoD,GACH,OAAO,KAIf,OAAOpD,IE3IftC,EAAYD,WACRgG,YAAa/F,EACbE,GAAI,KACJC,QAAS,KACTyG,OAAQ,KACRC,IAAK,KACLzG,QAAS,KAETR,MAAO,SAAUiH,GACb,IAAIC,EAAOlH,EAAMH,MAMjB,OALIoH,IACAC,EAAKD,IAAMA,GAEfC,EAAKF,OAASnH,KAEPqH,GAGXjF,MAAO,SAAUlB,GACb,IAGIW,EAAQ6E,EAHRhG,EAAUV,KAAKU,QACfC,EAAUX,KAAKW,QACfH,EAAMR,KAAKQ,IAiBf,OAdMU,KAAUR,IACZgG,EAAQ1G,KAAKQ,IAAI+F,iBACjB1E,EAAS7B,KAAKG,SACPM,GAAKiG,EACZ7E,EAAOnB,WACPmB,EAAOlB,WAEPA,EAAQA,EAAQ+C,QAAUxC,EAE1BR,EAAQQ,GAAUW,EAElBrB,EAAIgG,OAAOxG,KAAKS,IAAIS,GAAUwF,GAG3BhG,EAAQQ,IAInBmB,OAAQ,SAAUpB,EAAMI,EAAQK,GAC5B1B,KAAKQ,IAAIoG,eAAe5G,KAAKS,GAAIQ,EAAMI,EAAQK,KE1CvD,IAAIyB,EAAe,+CCRfmE,GACIvE,SAAU,EACVwE,YAAa,EACbC,SAAU,GAUlB5C,EAAOtE,WACHgG,YAAa1B,EACbtC,KAAM,KACNrB,KAAM,KACNwG,MAAO,KACPC,YAAa,EACb/E,KAAM,EACNC,GAAI,EAEJuE,OAAQ,KACRQ,MAAO,KACPC,KAAM,KACNpG,KAAM,KACNqG,SAAU,KAEV/C,QAAS,SAAUD,GACf,IAAIiD,EAAQR,EACZtH,KAAK6E,KAAOH,WAASoD,EAAOjD,GACZiD,EAAMjD,GAAQiD,EAAMC,QCX5ChD,EAAazE,WACTgG,YAAavB,EACbiD,QAAS,GACTC,SAAS,EACTpF,QAAS,KACTqF,OAAO,EACPC,WAAW,EACXC,MAAO,KAEPC,SACIC,UACIC,EAAG,QACHC,EAAG,aAIPC,aACIF,EAAG,QACHC,EAAG,YACHE,EAAG,SACHC,EAAG,WAGPC,UACIL,EAAG,QACHC,EAAG,aAGPK,WACIN,EAAG,QACHC,EAAG,SACHE,EAAG,UACHC,EAAG,YAEPG,WACAC,eAGJT,SAAU,WACN,IAAIU,EAAKhJ,KAIT,OAFAgJ,EAAG3H,OAAS2H,EAAGC,eAER,GAGXR,YAAa,SAAU9F,GACnB,IASIL,EAAMM,EAAIsG,EAAKhI,EATf8H,EAAKhJ,KACLgF,EAASgE,EAAGhE,OACZxE,EAAMwE,EAAOxE,IACbqG,EAAOrG,EAAIqG,KACXL,EAAShG,EAAIgG,OACbE,EAAQsC,EAAGG,OACXpB,EAAQ/C,EAAOzC,UAAU6G,SAASzG,EACAqG,EAAGhB,SAKzC,GAAID,EAAO,CAKP,GAJAzF,EAAOyF,EAAM,GACbnF,EAAKmF,EAAM,IAGN/H,KAAKqJ,kBAAkBtB,GAExB,OADAiB,EAAG3H,OAASuB,EACL,EAcX,GAXA1B,EAAS,IAAI0D,EAAO,YACpB1D,EAAOoB,KAAOA,EACdpB,EAAOuG,MAAQM,EAAM,GACrB7G,EAAOyB,KAAOA,EACdzB,EAAO0B,GAAKA,EAEZoG,EAAGC,eAAiBrG,EACpBoG,EAAG3H,OAASH,EAGZgI,EAAM1C,EAAOE,GACTpE,KAAQ4G,EACR,OAAO,EAMf,OAAIF,EAAGM,OAAO5F,QAAUgD,KAASG,EACtB,GAIXmC,EAAG3H,OAAS,gBACL,IAIXuH,SAAU,SAAU1H,GAChB,IAAI8H,EAAKhJ,KACLsJ,EAASN,EAAGM,OACZ9C,EAASwC,EAAGhE,OAAOxE,IAAIgG,OACvBE,EAAQsC,EAAGG,OACX7G,EAAOpB,EAAOoB,KAWlB,OATAgH,EAAOA,EAAO5F,SAAWgD,EAAOxF,GAEhC8H,EAAGG,OAAS3C,EAAOE,GAAOpE,GAC1B0G,EAAGnG,QAAU3B,EACb8H,EAAG3H,OAAS,KAGZ2H,EAAGf,QAAmB,MAAT3F,EACb0G,EAAG3H,OAAS2H,EAAGC,eACR,GAIXJ,UAAW,SAAU3H,GACjB,IAeIqI,EAAOxI,EAAM4B,EAAMC,EAAIsG,EAAKtB,EAf5BoB,EAAKhJ,KACLQ,EAAMwI,EAAGhE,OAAOxE,IAChB8I,EAASN,EAAGM,OACZE,EAAKF,EAAO5F,OACZmD,EAAOrG,EAAIqG,KACXL,EAAShG,EAAIgG,OACbE,EAAQsC,EAAGG,OACX9G,EAASwE,EAAKH,GACdpE,EAAOD,EAAO,GACdhB,EAASgB,EAAO,GAChBL,EAAIX,EACJoI,EAAWzH,EAAI,EACfS,EAAU,IAAImC,EAAO,eACrB8E,KAQJ,IAJAjH,EAAQH,KAAOA,EACfG,EAAQxB,KAAOoB,EAAO,GACtBuF,EAAO,KAEA5F,KAEH0E,GADA3F,EAAOuI,IAASE,IACH,GAIb7G,GAHA4G,EAAQxI,EAAK,IAGA4B,KACTX,IAAMyH,IACN7G,EAAK2G,EAAM3G,IAIf2G,EAAMpC,OAAS1E,EAEXmF,GACAA,EAAKC,SAAW0B,EAChBA,EAAM/H,KAAOoG,GAGbnF,EAAQmF,KAAO2B,EAEnB9G,EAAQkF,MAAQC,EAAO2B,EACvBG,EAAO1H,GAAKuH,EAAM9B,MActB,OAXAhF,EAAQgF,MAAQiC,EAChBjH,EAAQE,KAAOA,EACfF,EAAQG,GAAKA,EAEb0G,EAAO5F,OAAS8F,EAEhBR,EAAGnG,QAAUJ,EAEbA,EAAQiF,YAAcrG,EAGT,SAATiB,EAGW,IAAPkH,GACAD,EAAQ9G,EAAQkF,MAEhBlF,EAAQqC,QAAQ,OAChBrC,EAAQmF,KAAO2B,EACf9G,EAAQgF,OAAS8B,EAAM9B,OACvBhF,EAAQxB,KAAOT,EAAIyB,KACnBQ,EAAQiF,YAAc,EAEtBsB,EAAG3H,OAASoB,EAEL,IAGPuG,EAAG3H,OAAS,qBACL,IAKfiI,EAAOE,MAAS9C,EAAOjE,GACvBuG,EAAGf,SAAU,EAGbvB,EAAQF,EAAOE,GAAOpE,GACtB4G,EAAM1C,EAAOE,GAEbpE,EAAOpB,EAAOoB,KACd0G,EAAGG,OAASzC,EAGRpE,KAAQ4G,EACD,EAIFxC,KAASG,EACP,GAGXmC,EAAG3H,OAAS,gCACL,KAIX0H,WAAY,SAAU7H,GAClB,IAAI8H,EAAKhJ,KAOT,OALAgJ,EAAGb,UACCa,EAAGf,SAAU,EAEjBe,EAAGnG,QAAU3B,GAEN,GAGX4H,QAAS,SAAUV,GACf,IAAIY,EAAKhJ,KAKT,OAHAgJ,EAAGZ,MAAQA,EACXY,EAAGb,WAAY,GAER,GAGXkB,kBAAmB,SAAUtB,GACzB,QAASA,EAAM,KAAM/H,KAAKgF,OAAOxE,IAAIM,UAGzC6I,OAAQ,SAAUlC,GACd,IAAIuB,EAAKhJ,KACL6C,EAAUmG,EAAGnG,QAQjB,OANKmG,EAAGZ,OAASvF,IAEbA,EAAQ4E,MAAQA,GAIbzH,MAGXC,MAAO,WACH,IAAI+E,EAAShF,KAAKgF,OAElBhF,KAAKiJ,eAAiB,EACtBjJ,KAAK4J,OAAS,EACd5J,KAAKsJ,UAELtJ,KAAK0G,MAAQ1G,KAAK8B,MAClB9B,KAAKmJ,OAASnE,EAAOxE,IAAIsB,MACzB9B,KAAKqB,OAAS,KAETrB,KAAKgI,gBACChI,KAAKkI,aAGTlI,KAAK6J,gBACL7J,KAAKoI,aAELpI,KAAKiI,eACLjI,KAAK6C,SAIhBiH,IAAK,SAAU9B,GACX,IAAK3E,SAAO2E,GACR,MAAM,IAAIvE,MAAM,qCAGpBzD,KAAKC,QACLD,KAAKgI,QAAUA,EACfhI,KAAKkI,OAAQ,GAKjB1G,KAAM,WACF,IAKIkF,EAAOrF,EAAQ0I,EAAQb,EAAKrG,EAL5BmG,EAAKhJ,KACLqI,EAAUW,EAAGX,QACb2B,EAAWC,SACX9B,EAAYa,EAAGb,UACfF,GAAU,EAQd,IAJKE,UACMa,EAAGnG,SAGNsF,GAAY,CAMhB,GAJAzB,EAAQsC,EAAGtC,MACXrF,EAAS2H,EAAG3H,SAGNqF,KAASsC,GACX,MAAM,IAAIvF,MAAM,8BAAgCiD,GAWpD,GAPAqD,EAASf,EAAGtC,GAAOrF,GACnB4G,EAAUe,EAAGf,eACNe,EAAGf,QACVpF,EAAUmG,EAAGnG,QACbsF,EAAYa,EAAGb,UAGXa,EAAGZ,MACH,MAIJ,IAAKD,EAAW,CAGZ,IAAK6B,EAASD,GACV,MAAM,IAAItG,MA7VF,oCA6VgCiD,GAM5C,GAFAwC,EAAMb,EAAQ3B,KAERqD,KAAUb,GACZ,MAAM,IAAIzF,MApWF,oCAoWgCiD,GAG5CsC,EAAGtC,MAAQwC,EAAIa,GAInB,IAAgB,IAAZ9B,EACA,OAAOpF,EAMf,QAAOmG,EAAGZ,QAAUD,IAAoB,OCnXhD,IACI7C,KAkCJJ,EAnC0B,OAwCIH,GCjB9BU,EAAOnF,WACH0H,QAAS,GACTzF,UAAW,KACX/B,IAAK,KACL0H,OAAO,EACP5B,YAAab,EAEbyE,SAAU,SAAU5H,GAChB,IACI6H,EADA5E,EAAM6E,EAGV,GAAIzE,UAAUjC,QAEV,KADAyG,EAAW5E,EAAIjD,IAEX,MAAM,IAAImB,MAAM,yCAIpB0G,EAAW5E,EDzCG,QC4ClB,OAAO,IAAI4E,EAASnK,OAGxBY,OAAQ,SAAUqB,EAAMoC,EAAYvD,GAChC,IACIoH,EADA3D,EAAUf,QAOd,GAJKe,EAAQzD,KACTA,OAGCuC,SAAOpB,GACR,MAAM,IAAIwB,MAAM,wCAGpB,IAAKc,EAAQF,GACT,MAAM,IAAIZ,MAAM,8CAUpB,OANAzD,KAAKkI,MAAQA,EAAQmC,EAAQpI,EACDjC,KAAKQ,IACLR,KAAKuC,UACL8B,EACAvD,GAErBoH,GAIX/B,SAAU,SAAUL,GAChB,IACIwE,EADAvD,EAAW9B,SAGf,GAAI5B,SAAOyC,GACP,IACIA,EAAOC,KAAKC,MAAMF,GAEtB,MAAOG,GACH,MAAM,IAAIxC,MAAM,uCAIxB,IAAKsD,EAASjB,GACV,MAAM,IAAIrC,MAAM,kCAKpB,GAFA6G,EAAWxE,EAAKyE,QAEXxD,EAASuD,GACV,MAAM,IAAI7G,MAAM,gDAMpB,OAHAzD,KAAKuC,UAAU4D,SAASmE,GACxBtK,KAAKQ,IAAIsG,aAAahB,GAEf9F,MAIXwK,OAAQ,WACJ,OAAOzE,KAAKmB,UAAUlH,KAAKgH,aAG/BA,SAAU,WACN,IAAI/B,EAEJ,IAAKjF,KAAKkI,MACN,MAAM,IAAIzE,MAAM,qCAMpB,OAHAwB,EAASjF,KAAKQ,IAAIwG,WAClB/B,EAAOsF,OAASvK,KAAKuC,UAAUyE,WAExB/B,GAGXe,MAAO,SAAUgC,EAASyC,EAASP,GAC/B,IAGIhJ,EAAQoB,EAAMmF,EAHdrE,EAAWC,SACXqH,KACAC,EAAK,EAGT,IAAKvH,EAAS4E,GACV,MAAM,IAAIvE,MAAM,oCAOpB,KAJAyG,EAAW9G,EAAS8G,GACJlK,KAAKkK,SAASA,GACdlK,KAAKkK,YAGjB,MAAM,IAAIzG,MAAM,+BASpB,IANKwB,SAAOwF,KACRA,MAGJP,EAASJ,IAAI9B,GAER9G,EAASgJ,EAAS1I,OAAQN,EAAQA,EAASgJ,EAAS1I,OACrDkJ,EAAIC,KAAQzJ,GAEZoB,EAAOpB,EAAOoB,QACFmI,SAGa,KAFrBhD,EAAQgD,EAAQnI,GAAMA,EAAMpB,EAAOuG,MAAOvG,IAGtCA,EAAOuG,MAAQA,EAEQ,IAAlBvG,EAAOG,SACZH,EAAOuG,MAAQ,OAO3B,OAAOyC,EAAS9B,OAAgBsC"}